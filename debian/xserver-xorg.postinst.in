#!/bin/sh
# Debian xserver-xorg package post-installation script
# Copyright 1998-2004 Branden Robinson.
# Copyright 2004-2005 Canonical Ltd.
# Licensed under the GNU General Public License, version 2.  See the file
# /usr/share/common-licenses/GPL or <http://www.gnu.org/copyleft/gpl.txt>.
# Acknowledgements to Stephen Early, Mark Eichin, and Manoj Srivastava.

set -e

# source debconf library
. /usr/share/debconf/confmodule

THIS_PACKAGE=xserver-xorg
THIS_SCRIPT=postinst

#INCLUDE_SHELL_LIB#

if [ -e /etc/default/xorg ]; then
  . /etc/default/xorg
fi

if [ "x$XORG_CONFIG" = "xcustom" ]; then
  # leave configuration alone
  warn "not updating configuration as per \$XORG_CUSTOM"
  exit 0
fi

# the error-out function
bomb () {
  echo "$PROGNAME: error: $*" | fold -s -w "${COLUMNS:-80}" >&2
  exit 1
}

debug_echo () {
  # Syntax: debug_echo message ...
  if [ -n "$DEBUG_XORG_DEBCONF" ] || [ "$DEBCONF_DEBUG" = "user" ] \
    || [ "$DEBCONF_DEBUG" = '.*' ]; then
    DEBUG_XORG_PACKAGE="yes" observe "$*"
  fi
}

CONFIG_DIR="/etc/X11"
CONFIG_AUX_DIR=/var/lib/x11
SERVER_SYMLINK="$CONFIG_DIR/X"
XORGCONFIG="$CONFIG_DIR/xorg.conf"
CONFIG_AUX_DIR="/var/lib/x11"
SERVER_SYMLINK_CHECKSUM="$CONFIG_AUX_DIR/${SERVER_SYMLINK##*/}.md5sum"
SERVER_SYMLINK_ROSTER="$CONFIG_AUX_DIR/${SERVER_SYMLINK##*/}.roster"
XORGCONFIG_CHECKSUM="$CONFIG_AUX_DIR/${XORGCONFIG##*/}.md5sum"
XORGCONFIG_ROSTER="$CONFIG_AUX_DIR/${XORGCONFIG##*/}.roster"
THIS_SERVER=/usr/bin/Xorg

MULTIHEAD=

# get machine architecture
ARCH=$(dpkg --print-installation-architecture)

debug_report_status () {
  # Syntax: debug_report_status command exit_status
  debug_echo "$1 exited with status $2"
}

validate_string_db_input () {
  # Syntax: validate_string_db_input priority template
  #
  # validate string input; can't have doublequotes
  # If $MAY_BE_NULL is a non-null value (e.g., "yes"), the string may be null.
  if [ $# -ne 2 ]; then
    echo "internal error: validate_string_db_input() called with wrong number of arguments: $*" >&2
    exit 1
  fi
  PRIORITY=$1
  TEMPLATE=$2
  db_get "$TEMPLATE"
  SAFE="$RET"
  set +e
  while :; do
    db_input "$PRIORITY" "$TEMPLATE"
    # is the question going to be asked?
    if [ $? -eq 30 ]; then
      break # no; bail out of validation loop
    fi
    db_go
    db_get "$TEMPLATE"
    if [ -n "$RET" ]; then
      if ! expr "$RET" : '.*".*' > /dev/null 2>&1; then
        break # valid input
      else
        ERROR=xserver-xorg/config/doublequote_in_string_error
      fi
    else
      if [ -n "$MAY_BE_NULL" ]; then
        break # valid (null) input
      else
        ERROR=xserver-xorg/config/null_string_error
      fi
    fi
    # we only get to this point if the input was invalid; restore the known
    # good value in case we are interrupted before the user provides a valid
    # one
    db_set "$TEMPLATE" "$SAFE"
    db_fset "$TEMPLATE" seen false
    # now show the user the error message
    db_fset "$ERROR" seen false
    db_input critical "$ERROR"
    db_go
  done
  set -e
}

validate_numeric_db_input () {
  # Syntax: validate_numeric_db_input priority template
  #
  # validate numeric input; must have only digits, can be null
  if [ $# -ne 2 ]; then
    echo "internal error: validate_numeric_db_input() called with wrong number of arguments: $*" >&2
    exit 1
  fi
  PRIORITY=$1
  TEMPLATE=$2
  db_get "$TEMPLATE"
  SAFE="$RET"
  set +e
  while :; do
    db_input "$PRIORITY" "$TEMPLATE"
    # is the question going to be asked?
    if [ $? -eq 30 ]; then
      break # no; bail out of validation loop
    fi
    db_go
    db_get "$TEMPLATE"
    if [ -z "$RET" ] || expr "$RET" : "[0-9]\+$" > /dev/null 2>&1; then
      break # valid input
    fi
    # we only get to this point if the input was invalid; restore the known
    # good value in case we are interrupted before the user provides a valid
    # one
    db_set "$TEMPLATE" "$SAFE"
    db_fset "$TEMPLATE" seen false
    # now show the user the error message
    db_fset xserver-xorg/config/nonnumeric_string_error seen false
    db_input critical xserver-xorg/config/nonnumeric_string_error
    db_go
  done
  set -e
}

validate_bus_id_db_input () {
  # Syntax: validate_bus_id_db_input priority template
  #
  # validate BusID input
  if [ $# -ne 2 ]; then
    echo "internal error: validate_bus_id_db_input() called with wrong number of arguments: $*" >&2
    exit 1
  fi
  PRIORITY=$1
  TEMPLATE=$2
  db_get "$TEMPLATE"
  SAFE="$RET"
  set +e
  while :; do
    db_input "$PRIORITY" "$TEMPLATE"
    # is the question going to be asked?
    if [ $? -eq 30 ]; then
      break # no; bail out of validation loop
    fi
    db_go
    db_get "$TEMPLATE"
    case "$RET" in
      "")
        # An empty string is valid.
        break
        ;;
      ISA:*)
        # Looks like an ISA bus ID specification string.  At least up to a
        # point; upstream (xf86ParseIsaBusString() in
        # xc/programs/Xserver/hw/xfree86/common/xf86isaBus.c) doesn't actually
        # *supply* a specification.  So if the user's gotten this far, it's good
        # enough.
        break
        ;;
      PCI:*)
        # Looks like a PCI bus ID specification; validate it.  (We can use &&
        # outside a conditional here because of the "set +e" above.)
        expr "$RET" : "PCI:[0-9]\{1,3\}:[0-9]\{1,3\}:[0-9]\{1,3\}$" >/dev/null \
          2>&1 && break
        ;;
      SBUS:*)
        # Looks like an SBUS bus ID specification; validate it.  (We can use &&
        # outside a conditional here because of the "set +e" above.)
        #
        # According to upstream (xf86ParseSbusBusString() in
        # xc/programs/Xserver/hw/xfree86/common/xf86sbusBus.c):
        #
        # The format is assumed to be one of:
        # * "fbN", e.g. "fb1", which means the device corresponding to /dev/fbN
        # * "nameN", e.g. "cgsix0", which means Nth instance of card NAME
        # * "/prompath", e.g. "/sbus@0,10001000/cgsix@3,0" which is
        #   PROM pathname to the device.
        #
        # Well, okay.
        #
        # Accept any non-null sequence of lowercase letters followed by a
        # non-null sequence of decimal digits.  This handles "fbN" and "nameN".
        expr "$RET" : "SBUS:[a-z]\+[0-9]\+" >/dev/null 2>&1 && break
        # Now for the PROM path.  I am lazy; accept a slash followed a non-null
        # sequence of letters and commas, an at sign, a non-null sequence of
        # hexadecimal digits, a comma, and another non-null sequence of
        # hexadecimal digits.  Furthermore, accept multiple occurences of this
        # entire sequence.  Whew.
        expr "$RET" : "SBUS:\(/[A-Za-z,]\+@[0-9A-Fa-f]\+,[0-9A-Fa-f]\+\)\+$" \
          >/dev/null 2>&1 && break
        ;;
      [0-9])
        # Accept a simple decimal integer for legacy buses that haven't been
        # properly implemented (e.g., for SGI Indigo2 XL).
        break
        ;;
      *)
    esac
    # we only get to this point if the input was invalid; restore the known good
    # value in case we are interrupted before the user provides a valid one
    db_set "$TEMPLATE" "$SAFE"
    db_fset "$TEMPLATE" seen false
    # now show the user the error message
    db_fset xserver-xorg/config/device/bus_id_error seen false
    db_input critical xserver-xorg/config/device/bus_id_error
    db_go
  done
  set -e
}

auto_answer () {
  # Syntax: auto_answer input_command priority template default_answer
  #
  # Used to auto-answer questions that don't have reasonable defaults.  Some
  # people insist on running the xserver-xorg config script with the
  # non-interactive frontend.  For this to work, the debconf database will need
  # to be pre-loaded with answers to several questions.  You have been
  # warned...
  if [ $# -ne 4 ]; then
    echo "internal error: auto_answer() called with wrong number of arguments: $*" >&2
    exit 1
  fi
  INPUT_COMMAND=$1
  PRIORITY=$2
  TEMPLATE=$3
  DEFAULT_ANSWER=$4
  set +e
  debug_echo "auto_answer() \"$INPUT_COMMAND $PRIORITY $TEMPLATE\" with default \"$DEFAULT_ANSWER\""
  db_fget "$TEMPLATE" seen
  # are we re-configuring?
  if [ -z "$FIRSTINST" ] && [ "$RET" = "true" ]; then
    # yes, we are reconfiguring
    db_get "$TEMPLATE"
    debug_echo "auto_answer: (reconfiguring) preserving existing answer \"$RET\""
  else
    # not reconfiguring; has the question been seen before?
    if [ "$RET" = "true" ]; then
      db_get "$TEMPLATE"
      debug_echo "auto_answer: (not reconfiguring) preserving existing answer \"$RET\""
    else
      debug_echo "auto_answer: auto-answering with \"$DEFAULT_ANSWER\""
      db_set $TEMPLATE "$DEFAULT_ANSWER"
    fi
  fi
  "$INPUT_COMMAND" "$PRIORITY" "$TEMPLATE"
  if [ $? -eq 30 ]; then
    debug_echo "auto_answer: $TEMPLATE is not being asked"
  else
    debug_echo "auto_answer: asking $TEMPLATE"
  fi
  set -e
  db_go
  db_get "$TEMPLATE"
  debug_echo "auto_answer: $TEMPLATE is \"$RET\""
}

priority_ceil() {
  # syntax: priority_ceil requested_priority
  #
  # Given a variable PRIORITY_CEILING and a "requested_priority" argument, echo
  # a debconf priority string corresponding to the lesser of the two.

  # Implementation note: a clever version of this could be done using "eval",
  # or embedding a Perl script, but those would be more difficult to maintain.
  # Better just to go the simple and stupid route.  Yes, I know this is not
  # very efficient.

  # Validate arguments.
  if [ $# -ne 1 ]; then
    debug_echo "priority_ceil() called with empty or bogus arguments \"$*\";" \
               "assuming argument of \"low\""
    _requested_priority=low
  else
    _requested_priority="$1"
  fi

  # If PRIORITY_CEILING is null or unset, it's same as not having one at all;
  # the sky's the limit.  We use a locally scoped priority_ceiling variable
  # because we don't want to affect the value of the global one.
  _priority_ceiling=${PRIORITY_CEILING:-"critical"}

  # Ensure the value of _priority_ceiling is reasonable.
  if [ "$_priority_ceiling" != "critical" ] && \
       [ "$_priority_ceiling" != "high" ] && \
       [ "$_priority_ceiling" != "medium" ] && \
       [ "$_priority_ceiling" != "low" ]; then
    debug_echo "priority_ceil() called with bogus value of \$PRIORITY_CEILING" \
               "\"$_priority_ceiling\"; treating as \"critical\""
    _priority_ceiling=critical
  fi

  case "$_requested_priority" in
    critical)
      # This is the highest priority, so there is nowhere to go but down.
      echo "$_priority_ceiling"
      ;;
    high)
      case "$_priority_ceiling" in
        critical)
          echo "$_requested_priority"
          ;;
        high|medium|low)
          echo "$_priority_ceiling"
          ;;
      esac
      ;;
    medium)
      case "$_priority_ceiling" in
        critical|high)
          echo "$_requested_priority"
          ;;
        medium|low)
          echo "$_priority_ceiling"
          ;;
      esac
      ;;
    low)
      # This is the lowest priority, so we can't go any lower.
      echo "$_requested_priority"
      ;;
    *)
      debug_echo "priority_ceil() called with bogus argument" \
                 "\"$_requested_priority\"; returning \"low\""
      echo low
      ;;
  esac
}

# analyze arguments; used by auto_answer()
if [ "$1" = "reconfigure" ] || [ -n "$DEBCONF_RECONFIGURE" ]; then
  RECONFIGURE=true
else
  RECONFIGURE=
fi

if [ -z "$2" ]; then
  FIRSTINST=yes
fi

debug_echo "Configuring $THIS_PACKAGE."

if [ -n "$FIRSTINST" ] || [ -n "$RECONFIGURE" ]; then
  # BusID
  PRIORITY=low
  DEFAULT=

  # Some PowerPCs need to be told where to find the video card even if there is
  # only one in the machine (broken PCI bus code in the XFree86 X server, most
  # likely).  If there are multiple video cards, we need to configure one as the
  # primary head.
  if [ "$ARCH" = "powerpc" ] || [ "$MULTIHEAD" = "yes" ]; then
    PRIORITY=medium
    if which lspci > /dev/null 2>&1; then
      # Try to guess the correct BusID.
      VIDEO_CARD=$(LC_ALL=C lspci -n | grep -E "(Class )?0300:" | sort -n | head -n 1 \
        | cut -d\  -f1)
      if [ -n "$VIDEO_CARD" ]; then
        # Recent versions of lspci report a four-digit domain as the first field.
        if expr "$VIDEO_CARD" : ".*:.*:.*\..*" >/dev/null 2>&1; then
          # We have an entry in "hex:hex:hex.hex" format; we need
          # "PCI:decimal:decimal:decimal" (we don't use the domain).
          DOMAIN=$(printf "%d" 0x$(echo $VIDEO_CARD | cut -d: -f1) )
          BUS=$(printf "%d" 0x$(echo $VIDEO_CARD | cut -d: -f2) )
          DEVICE=$(printf "%d" 0x$(echo $VIDEO_CARD | cut -d: -f3 | cut -d. -f1) )
          FUNCTION=$(printf "%d" 0x$(echo $VIDEO_CARD | cut -d. -f2) )
          DEFAULT="PCI:$BUS:$DEVICE:$FUNCTION"
        elif expr "$VIDEO_CARD" : ".*:.*\..*" >/dev/null 2>&1; then
          # We have an entry in "hex:hex.hex" format; we need
          # "PCI:decimal:decimal:decimal".
          BUS=$(printf "%d" 0x$(echo $VIDEO_CARD | cut -d: -f1) )
          DEVICE=$(printf "%d" 0x$(echo $VIDEO_CARD | cut -d: -f2 | cut -d. -f1) )
          FUNCTION=$(printf "%d" 0x$(echo $VIDEO_CARD | cut -d. -f2) )
          DEFAULT="PCI:$BUS:$DEVICE:$FUNCTION"
        else
          warn "unrecognized output from lspci: \"$VIDEO_CARD\""
        fi
      fi
    fi
  fi

  # SGI Indigo2 XLs require a special hack, per Guido Guenther (see Debian
  # #249614).
  if [ -e /proc/cpuinfo ]; then
    if grep -q "system type.*:.*SGI Indigo2" /proc/cpuinfo; then
      PRIORITY=medium
      DEFAULT=1
    fi
  fi

  # For most people, asking this question at all is a bad idea. Only do it
  # if we have a need to do so, as defined by setting the priority
  if [ "$PRIORITY" = "medium" ]; then
    # this question requires input validation
    if [ -n "$DEFAULT" ]; then
      auto_answer validate_bus_id_db_input "$(priority_ceil $PRIORITY)" xserver-xorg/config/device/bus_id "$DEFAULT"
    else
      validate_bus_id_db_input "$(priority_ceil $PRIORITY)" xserver-xorg/config/device/bus_id || debug_report_status "validate_bus_id_db_input $(priority_ceil $PRIORITY) xserver-xorg/config/device/bus_id" "$?"
    fi
  else
    db_set xserver-xorg/config/device/bus_id ""
  fi
fi

# files and dri sections
if [ -e "$CONFIG_AUX_DIR/.migrateconfig" ]; then
  AUTODETECT_VIDEO="yes"
  rm -f $CONFIG_AUX_DIR/.migrateconfig
fi

#DEBHELPER#

# register this package as a (potential) handler of the X server symlink and
# X.Org X server configuration file
for ROSTER in "$SERVER_SYMLINK_ROSTER" "$XORGCONFIG_ROSTER"; do
  if ! fgrep -qsx "$THIS_PACKAGE" "$ROSTER"; then
    echo "$THIS_PACKAGE" >> "$ROSTER"
  fi
done

# only mess with the server symlink file if it is a symbolic link or does
# not exist.  otherwise, assume that's the way the user wants it.
if ! [ -e "$SERVER_SYMLINK" ]; then
  ln -s "$THIS_SERVER" "$SERVER_SYMLINK"
# recover from an old bug
elif [ `readlink "$SERVER_SYMLINK"` = "/bin/true" ]; then
  rm -f "$SERVER_SYMLINK"
  ln -s "$THIS_SERVER" "$SERVER_SYMLINK"
fi

if [ -n "$UPGRADE" ]; then
    if dpkg --compare-versions "$2" le "1:7.3+5"; then
        # Clean up our old crap
        rm -f "$SERVER_SYMLINK_CHECKSUM" "$SERVER_SYMLINK_ROSTER"
        for QUESTION in "shared/default-x-server" \
                        "xserver-xorg/autodetect_mouse" \
                        "xserver-xorg/autodetect_monitor" \
                        "xserver-xorg/autodetect_video_card" \
                        "xserver-xorg/config/device/identifier" \
                        "xserver-xorg/config/monitor/selection-method" \
                        "xserver-xorg/config/monitor/screen-size" \
                        "xserver-xorg/config/monitor/mode-list" \
                        "xserver-xorg/config/monitor/default-identifier" \
                        "xserver-xorg/config/monitor/horiz-sync" \
                        "xserver-xorg/config/monitor/vert-refresh" \
                        "xserver-xorg/config/monitor/range_input_error" \
                        "xserver-xorg/config/display/modes" \
                        "xserver-xorg/config/device/video_ram" \
                        "xserver-xorg/config/display/default_depth" \
                        "xserver-xorg/config/inputdevice/mouse/port" \
                        "xserver-xorg/config/inputdevice/mouse/protocol" \
                        "xserver-xorg/config/inputdevice/mouse/emulate3buttons" \
                        "xserver-xorg/config/modules" \
                        "xserver-xorg/config/monitor/default-identifier" \
                        "xserver-xorg/config/monitor/identifier" \
                        "xserver-xorg/config/write_files_section" \
                        "xserver-xorg/multiple_possible_x-drivers"; do
          db_unregister "$QUESTION" || true
        done
    fi
    if dpkg --compare-versions "$2" lt-nl 1:7.4; then
      for QUESTION in \
	xserver-xorg/config/device/use_fbdev \
	xserver-xorg/config/inputdevice/keyboard/rules \
	xserver-xorg/config/inputdevice/keyboard/model \
	xserver-xorg/config/inputdevice/keyboard/layout \
	xserver-xorg/config/inputdevice/keyboard/variant \
	xserver-xorg/config/inputdevice/keyboard/options \
	xserver-xorg/autodetect_keyboard; do
	db_unregister $QUESTION || true
      done
    fi
fi

if [ -n "$UPGRADE" ] && dpkg --compare-versions "$2" lt 1:7.4+6; then
  db_unregister xserver-xorg/config/device/driver || true
fi

# no debconf interaction should be done after this point
# (the dexconf call below invokes db_stop)

# Don't touch the config on upgrades except to deal with known issues with old
# configs.
if [ -n "$RECONFIGURE" ]; then
  # prepare a new version
  NEW_XORGCONFIG="$XORGCONFIG.dpkg-new"
  if [ -n "$RECONFIGURE" ] && [ -e "$XORGCONFIG" ]; then
    BACKUP_XORGCONFIG="$XORGCONFIG.$(date '+%Y%m%d%H%M%S')"
    if [ -e "$BACKUP_XORGCONFIG" ]; then
      bomb "backup xorg.conf file $BACKUP_XORGCONFIG already" \
           "exists; please remove it and try again"
    fi
    cp "$XORGCONFIG" "$BACKUP_XORGCONFIG"
    warn "overwriting possibly-customised configuration file; backup" \
         "in $BACKUP_XORGCONFIG"
  fi
  if dexconf -o "$NEW_XORGCONFIG"; then
    if ! cmp -s "$XORGCONFIG" "$NEW_XORGCONFIG"; then
      mv "$NEW_XORGCONFIG" "$XORGCONFIG"
      md5sum "$XORGCONFIG" > "$XORGCONFIG_CHECKSUM"
    fi
  else
    warn "error while preparing new Xorg X server configuration" \
         "file in $NEW_XORGCONFIG; not attempting to update existing" \
         "configuration"
  fi
  rm -f "$NEW_XORGCONFIG"
elif dpkg --compare-versions "$2" lt-nl "1:7.4~3"; then
  # We're upgrading from pre-7.4.  We need to replace i810 with intel, and
  # via with openchrome.
  if [ -e "$XORGCONFIG" ]; then
    LC_ALL=C sed -e'
	/^[[:space:]]*Section[[:space:]]\+"Device"[[:space:]]*$/I,/^[[:space:]]*EndSection[[:space:]]*$/I {
	/^[[:space:]]*Driver[[:space:]]\+"i810"/I s/i810/intel/I
	/^[[:space:]]*Driver[[:space:]]\+"via"/I s/via/openchrome/I
	}
	' $XORGCONFIG > ${XORGCONFIG}.madwizard-new
    if ! cmp -s $XORGCONFIG ${XORGCONFIG}.madwizard-new; then
      # compare the current and stored checksums; if they do not match, assume
      # that's the way the user wants it.
      if [ "$(md5sum "$XORGCONFIG")" != "$(cat "$XORGCONFIG_CHECKSUM")" ]; then
        BACKUP_XORGCONFIG="$XORGCONFIG.$(date '+%Y%m%d%H%M%S')"
        warn "$XORGCONFIG has been customized, but we need to make updates. Backing up your config to $BACKUP_XORGCONFIG. If we screw something up, restore using this file."
        cp "$XORGCONFIG" "$BACKUP_XORGCONFIG"
      else
        # checksums match, update the checksum
        md5sum "${XORGCONFIG}.madwizard-new" > "$XORGCONFIG_CHECKSUM"
      fi
      chown --reference=$XORGCONFIG ${XORGCONFIG}.madwizard-new
      chmod --reference=$XORGCONFIG ${XORGCONFIG}.madwizard-new
      mv ${XORGCONFIG}.madwizard-new $XORGCONFIG
    else
      rm ${XORGCONFIG}.madwizard-new
    fi
  fi
else
  debug_echo "not updating $XORGCONFIG; we're upgrading"
fi

case "$1" in
  configure)
    if dpkg --compare-versions "$2" lt-nl "1:7.3+11"; then
      remove_conffile_commit "/etc/init.d/xserver-xorg"
    fi
    if dpkg --compare-versions "$2" lt-nl "1:7.3+13"; then
      update-rc.d xserver-xorg remove || true
    fi
    ;;
esac

exit 0

# vim:set ai et sts=2 sw=2 tw=0:
