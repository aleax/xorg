#!/bin/sh
# Debian xserver-xorg package post-installation script
# Copyright 1998-2004 Branden Robinson.
# Copyright 2004-2005 Canonical Ltd.
# Licensed under the GNU General Public License, version 2.  See the file
# /usr/share/common-licenses/GPL or <http://www.gnu.org/copyleft/gpl.txt>.
# Acknowledgements to Stephen Early, Mark Eichin, and Manoj Srivastava.

set -e

# source debconf library
. /usr/share/debconf/confmodule

THIS_PACKAGE=xserver-xorg
THIS_SCRIPT=postinst

#INCLUDE_SHELL_LIB#

if [ -e /etc/default/xorg ]; then
  . /etc/default/xorg
fi

if [ "x$XORG_CONFIG" = "xcustom" ]; then
  # leave configuration alone
  warn "not updating configuration as per \$XORG_CUSTOM"
  exit 0
fi

# the error-out function
bomb () {
  echo "$PROGNAME: error: $*" | fold -s -w "${COLUMNS:-80}" >&2
  exit 1
}

debug_echo () {
  # Syntax: debug_echo message ...
  if [ -n "$DEBUG_XORG_DEBCONF" ] || [ "$DEBCONF_DEBUG" = "user" ] \
    || [ "$DEBCONF_DEBUG" = '.*' ]; then
    DEBUG_XORG_PACKAGE="yes" observe "$*"
  fi
}

validate_string_db_input () {
  # Syntax: validate_string_db_input priority template
  #
  # validate string input; can't have doublequotes
  # If $MAY_BE_NULL is a non-null value (e.g., "yes"), the string may be null.
  if [ $# -ne 2 ]; then
    echo "internal error: validate_string_db_input() called with wrong number of arguments: $*" >&2
    exit 1
  fi
  PRIORITY="$1"
  TEMPLATE="$2"
  db_get "$TEMPLATE"
  SAFE="$RET"
  set +e
  while :; do
    db_input "$PRIORITY" "$TEMPLATE"
    # is the question going to be asked?
    if [ $? -eq 30 ]; then
      break # no; bail out of validation loop
    fi
    db_go
    db_get "$TEMPLATE"
    if [ -n "$RET" ]; then
      if ! expr "$RET" : '.*".*' > /dev/null 2>&1; then
        break # valid input
      else
        ERROR="xserver-xorg/config/doublequote_in_string_error"
      fi
    else
      if [ -n "$MAY_BE_NULL" ]; then
        break # valid (null) input
      else
        ERROR="xserver-xorg/config/null_string_error"
      fi
    fi
    # we only get to this point if the input was invalid; restore the known
    # good value in case we are interrupted before the user provides a valid
    # one
    db_set "$TEMPLATE" "$SAFE"
    db_fset "$TEMPLATE" seen false
    # now show the user the error message
    db_fset "$ERROR" seen false
    db_input critical "$ERROR"
    db_go
  done
  set -e
}

CONFIG_DIR="/etc/X11"
CONFIG_AUX_DIR=/var/lib/x11
SERVER_SYMLINK="$CONFIG_DIR/X"
XORGCONFIG="$CONFIG_DIR/xorg.conf"
CONFIG_AUX_DIR="/var/lib/x11"
SERVER_SYMLINK_CHECKSUM="$CONFIG_AUX_DIR/${SERVER_SYMLINK##*/}.md5sum"
SERVER_SYMLINK_ROSTER="$CONFIG_AUX_DIR/${SERVER_SYMLINK##*/}.roster"
XORGCONFIG_CHECKSUM="$CONFIG_AUX_DIR/${XORGCONFIG##*/}.md5sum"
XORGCONFIG_ROSTER="$CONFIG_AUX_DIR/${XORGCONFIG##*/}.roster"
THIS_SERVER=/usr/bin/Xorg

NCARDS=0
NSERVERS=0
NDRIVERS=0
MULTIHEAD=

# get machine architecture
ARCH=$(dpkg --print-installation-architecture)

debug_echo () {
  # Syntax: debug_echo message ...
  if [ -n "$DEBUG_XORG_DEBCONF" ] || [ "$DEBCONF_DEBUG" = "user" ] \
    || [ "$DEBCONF_DEBUG" = '.*' ]; then
    DEBUG_XORG_PACKAGE=yes observe "$*"
  fi
}

debug_report_status () {
  # Syntax: debug_report_status command exit_status
  debug_echo "$1 exited with status $2"
}

discover_sparc_video () {
  # Detect video cards on sparc by parsing prtconf output
  prtconf -p -v | awk '
  BEGIN {
          display_node = 0; 
          model = ""; 
          name = ""; 
  }
  /Node/ {
           if(display_node == 1) {
             printf "model=\"%s\" name=\"%s\"\n", model, name
             display_node = 0;
           };
           model = "";
           name = ""
  }
  /device_type:/ {
                   if(index($2, "display") != 0) {
                     display_node = 1
                   }
  }
  /model:/ { l=length($2); model = substr($2, 2, l-2) }
  /name:/  { l=length($2); name = substr($2, 2, l-2) }
  END{
       if(display_node == 1) {
         printf "model=\"%s\" name=\"%s\"\n", model, name
       }; 
  }' | \
  while read line
  do
    eval "${line}"
#   Match the name and the model to the driver.
    test -z "${name}" && continue
#   The model stored in the prom is usually not too
#   informative, so that we need to provide some
#   sensible human-readable card identification as well.
    server='XFree86'
    case "${name}" in
      'cgsix' )
        card='Sun CG6 framebuffer'
        driver='suncg6' 
	;;
      'SUNW,sx' )
        card='Sun CG14 framebuffer'
        driver='suncg14'
        ;;
      'SUNW,leo' )
        card='Sun LEO framebuffer'
        driver='sunleo'
        ;;
      'SUNW,tcx' )
        card='Sun TCX framebuffer' 
        driver='suntcx'
	;;
      'SUNW,m64B' )
        card='ATI Technologies 3D Rage Pro or similar'
        driver='ati'
        ;;
      'SUNW,ffb' )
        card='Sun Creator3D framebuffer or similar'
        driver='sunffb'
        ;;
      'SUNW,afb' )
        card='Sun Elite3D framebuffer or similar'
        driver='sunffb'
        ;;
      'TSI,gfxp' )
        card='PGX32 framebuffer or similar'
        driver='glint'
        ;;
      * )
        card='Unknown'
        server='unknown'
        driver='unknown'
        ;;
    esac
    if [ -n "${model}" ]; then
      card="${card} (${model})"
    fi
    echo -e "${card}\t${server}\t${driver}"
  done
}

validate_string_db_input () {
  # Syntax: validate_string_db_input priority template
  #
  # validate string input; can't have doublequotes
  # If $MAY_BE_NULL is a non-null value (e.g., "yes"), the string may be null.
  if [ $# -ne 2 ]; then
    echo "internal error: validate_string_db_input() called with wrong number of arguments: $*" >&2
    exit 1
  fi
  PRIORITY=$1
  TEMPLATE=$2
  db_get "$TEMPLATE"
  SAFE="$RET"
  set +e
  while :; do
    db_input "$PRIORITY" "$TEMPLATE"
    # is the question going to be asked?
    if [ $? -eq 30 ]; then
      break # no; bail out of validation loop
    fi
    db_go
    db_get "$TEMPLATE"
    if [ -n "$RET" ]; then
      if ! expr "$RET" : '.*".*' > /dev/null 2>&1; then
        break # valid input
      else
        ERROR=xserver-xorg/config/doublequote_in_string_error
      fi
    else
      if [ -n "$MAY_BE_NULL" ]; then
        break # valid (null) input
      else
        ERROR=xserver-xorg/config/null_string_error
      fi
    fi
    # we only get to this point if the input was invalid; restore the known
    # good value in case we are interrupted before the user provides a valid
    # one
    db_set "$TEMPLATE" "$SAFE"
    db_fset "$TEMPLATE" seen false
    # now show the user the error message
    db_fset "$ERROR" seen false
    db_input critical "$ERROR"
    db_go
  done
  set -e
}

validate_numeric_db_input () {
  # Syntax: validate_numeric_db_input priority template
  #
  # validate numeric input; must have only digits, can be null
  if [ $# -ne 2 ]; then
    echo "internal error: validate_numeric_db_input() called with wrong number of arguments: $*" >&2
    exit 1
  fi
  PRIORITY=$1
  TEMPLATE=$2
  db_get "$TEMPLATE"
  SAFE="$RET"
  set +e
  while :; do
    db_input "$PRIORITY" "$TEMPLATE"
    # is the question going to be asked?
    if [ $? -eq 30 ]; then
      break # no; bail out of validation loop
    fi
    db_go
    db_get "$TEMPLATE"
    if [ -z "$RET" ] || expr "$RET" : "[0-9]\+$" > /dev/null 2>&1; then
      break # valid input
    fi
    # we only get to this point if the input was invalid; restore the known
    # good value in case we are interrupted before the user provides a valid
    # one
    db_set "$TEMPLATE" "$SAFE"
    db_fset "$TEMPLATE" seen false
    # now show the user the error message
    db_fset xserver-xorg/config/nonnumeric_string_error seen false
    db_input critical xserver-xorg/config/nonnumeric_string_error
    db_go
  done
  set -e
}

validate_bus_id_db_input () {
  # Syntax: validate_bus_id_db_input priority template
  #
  # validate BusID input
  if [ $# -ne 2 ]; then
    echo "internal error: validate_bus_id_db_input() called with wrong number of arguments: $*" >&2
    exit 1
  fi
  PRIORITY=$1
  TEMPLATE=$2
  db_get "$TEMPLATE"
  SAFE="$RET"
  set +e
  while :; do
    db_input "$PRIORITY" "$TEMPLATE"
    # is the question going to be asked?
    if [ $? -eq 30 ]; then
      break # no; bail out of validation loop
    fi
    db_go
    db_get "$TEMPLATE"
    case "$RET" in
      "")
        # An empty string is valid.
        break
        ;;
      ISA:*)
        # Looks like an ISA bus ID specification string.  At least up to a
        # point; upstream (xf86ParseIsaBusString() in
        # xc/programs/Xserver/hw/xfree86/common/xf86isaBus.c) doesn't actually
        # *supply* a specification.  So if the user's gotten this far, it's good
        # enough.
        break
        ;;
      PCI:*)
        # Looks like a PCI bus ID specification; validate it.  (We can use &&
        # outside a conditional here because of the "set +e" above.)
        expr "$RET" : "PCI:[0-9]\{1,3\}:[0-9]\{1,3\}:[0-9]\{1,3\}$" >/dev/null \
          2>&1 && break
        ;;
      SBUS:*)
        # Looks like an SBUS bus ID specification; validate it.  (We can use &&
        # outside a conditional here because of the "set +e" above.)
        #
        # According to upstream (xf86ParseSbusBusString() in
        # xc/programs/Xserver/hw/xfree86/common/xf86sbusBus.c):
        #
        # The format is assumed to be one of:
        # * "fbN", e.g. "fb1", which means the device corresponding to /dev/fbN
        # * "nameN", e.g. "cgsix0", which means Nth instance of card NAME
        # * "/prompath", e.g. "/sbus@0,10001000/cgsix@3,0" which is
        #   PROM pathname to the device.
        #
        # Well, okay.
        #
        # Accept any non-null sequence of lowercase letters followed by a
        # non-null sequence of decimal digits.  This handles "fbN" and "nameN".
        expr "$RET" : "SBUS:[a-z]\+[0-9]\+" >/dev/null 2>&1 && break
        # Now for the PROM path.  I am lazy; accept a slash followed a non-null
        # sequence of letters and commas, an at sign, a non-null sequence of
        # hexadecimal digits, a comma, and another non-null sequence of
        # hexadecimal digits.  Furthermore, accept multiple occurences of this
        # entire sequence.  Whew.
        expr "$RET" : "SBUS:\(/[A-Za-z,]\+@[0-9A-Fa-f]\+,[0-9A-Fa-f]\+\)\+$" \
          >/dev/null 2>&1 && break
        ;;
      [0-9])
        # Accept a simple decimal integer for legacy buses that haven't been
        # properly implemented (e.g., for SGI Indigo2 XL).
        break
        ;;
      *)
    esac
    # we only get to this point if the input was invalid; restore the known good
    # value in case we are interrupted before the user provides a valid one
    db_set "$TEMPLATE" "$SAFE"
    db_fset "$TEMPLATE" seen false
    # now show the user the error message
    db_fset xserver-xorg/config/device/bus_id_error seen false
    db_input critical xserver-xorg/config/device/bus_id_error
    db_go
  done
  set -e
}

auto_answer () {
  # Syntax: auto_answer input_command priority template default_answer
  #
  # Used to auto-answer questions that don't have reasonable defaults.  Some
  # people insist on running the xserver-xorg config script with the
  # non-interactive frontend.  For this to work, the debconf database will need
  # to be pre-loaded with answers to several questions.  You have been
  # warned...
  if [ $# -ne 4 ]; then
    echo "internal error: auto_answer() called with wrong number of arguments: $*" >&2
    exit 1
  fi
  INPUT_COMMAND=$1
  PRIORITY=$2
  TEMPLATE=$3
  DEFAULT_ANSWER=$4
  set +e
  debug_echo "auto_answer() \"$INPUT_COMMAND $PRIORITY $TEMPLATE\" with default \"$DEFAULT_ANSWER\""
  db_fget "$TEMPLATE" seen
  # are we re-configuring?
  if [ -z "$FIRSTINST" ] && [ "$RET" = "true" ]; then
    # yes, we are reconfiguring
    db_get "$TEMPLATE"
    debug_echo "auto_answer: (reconfiguring) preserving existing answer \"$RET\""
  else
    # not reconfiguring; has the question been seen before?
    if [ "$RET" = "true" ]; then
      db_get "$TEMPLATE"
      debug_echo "auto_answer: (not reconfiguring) preserving existing answer \"$RET\""
    else
      debug_echo "auto_answer: auto-answering with \"$DEFAULT_ANSWER\""
      db_set $TEMPLATE "$DEFAULT_ANSWER"
    fi
  fi
  "$INPUT_COMMAND" "$PRIORITY" "$TEMPLATE"
  if [ $? -eq 30 ]; then
    debug_echo "auto_answer: $TEMPLATE is not being asked"
  else
    debug_echo "auto_answer: asking $TEMPLATE"
  fi
  set -e
  db_go
  db_get "$TEMPLATE"
  debug_echo "auto_answer: $TEMPLATE is \"$RET\""
}

priority_ceil() {
  # syntax: priority_ceil requested_priority
  #
  # Given a variable PRIORITY_CEILING and a "requested_priority" argument, echo
  # a debconf priority string corresponding to the lesser of the two.

  # Implementation note: a clever version of this could be done using "eval",
  # or embedding a Perl script, but those would be more difficult to maintain.
  # Better just to go the simple and stupid route.  Yes, I know this is not
  # very efficient.

  # Validate arguments.
  if [ $# -ne 1 ]; then
    debug_echo "priority_ceil() called with empty or bogus arguments \"$*\";" \
               "assuming argument of \"low\""
    _requested_priority=low
  else
    _requested_priority="$1"
  fi

  # If PRIORITY_CEILING is null or unset, it's same as not having one at all;
  # the sky's the limit.  We use a locally scoped priority_ceiling variable
  # because we don't want to affect the value of the global one.
  _priority_ceiling=${PRIORITY_CEILING:-"critical"}

  # Ensure the value of _priority_ceiling is reasonable.
  if [ "$_priority_ceiling" != "critical" ] && \
       [ "$_priority_ceiling" != "high" ] && \
       [ "$_priority_ceiling" != "medium" ] && \
       [ "$_priority_ceiling" != "low" ]; then
    debug_echo "priority_ceil() called with bogus value of \$PRIORITY_CEILING" \
               "\"$_priority_ceiling\"; treating as \"critical\""
    _priority_ceiling=critical
  fi

  case "$_requested_priority" in
    critical)
      # This is the highest priority, so there is nowhere to go but down.
      echo "$_priority_ceiling"
      ;;
    high)
      case "$_priority_ceiling" in
        critical)
          echo "$_requested_priority"
          ;;
        high|medium|low)
          echo "$_priority_ceiling"
          ;;
      esac
      ;;
    medium)
      case "$_priority_ceiling" in
        critical|high)
          echo "$_requested_priority"
          ;;
        medium|low)
          echo "$_priority_ceiling"
          ;;
      esac
      ;;
    low)
      # This is the lowest priority, so we can't go any lower.
      echo "$_requested_priority"
      ;;
    *)
      debug_echo "priority_ceil() called with bogus argument" \
                 "\"$_requested_priority\"; returning \"low\""
      echo low
      ;;
  esac
}

non_latin_keyboard () {
  NONLATINMAPS="am ar bg by cs el gr il ir iu lo lt mk ml mm mn ru th tj ua"
  for i in $NONLATINMAPS; do
    if [ "$XMAP" = "$i" ]; then
      NON_LATIN="true"
    fi
  done

  # Turkish F keyboards are non-Latin; Turkish Q aren't.
  if [ "$XMAP" = "tr" ] && [ "$VARIANT" = "f" ]; then
    NON_LATIN="true"
  fi
}

# analyze arguments; used by auto_answer()
if [ "$1" = "reconfigure" ] || [ -n "$DEBCONF_RECONFIGURE" ]; then
  RECONFIGURE=true
else
  RECONFIGURE=
fi

if [ -z "$2" ]; then
  FIRSTINST=yes
fi

debug_echo "Configuring $THIS_PACKAGE."

# collect information about installed video card(s), if possible
if [ "$ARCH" = "sparc" ]; then
  DISCOVER_PROG='prtconf'
  DISCOVER_FUNC='discover_sparc_video'

  if which $DISCOVER_PROG > /dev/null 2>&1; then
    DISCOVERED_VIDEO=$($DISCOVER_FUNC)
    MULTIHEAD=$(echo "$DISCOVERED_VIDEO" | wc -l)
    DISCOVERED_VIDEO=$(echo "$DISCOVERED_VIDEO" | head -n 1)
    if [ -n "$DISCOVERED_VIDEO" ]; then
      NCARDS=$(echo "$DISCOVERED_VIDEO" | wc -l)
      SERVERS=$(echo "$DISCOVERED_VIDEO" | awk 'BEGIN { FS="\t" } {print $2}' | grep -v unknown | sort | uniq)
      if [ -n "$SERVERS" ]; then
        NSERVERS=$(echo "$SERVERS" | wc -l)
      fi
      DRIVERS=$(echo "$DISCOVERED_VIDEO" | awk 'BEGIN { FS="\t" } {print $NF}' | grep -v unknown | sort | uniq)
      if [ -n "$DRIVERS" ]; then
        NDRIVERS=$(echo "$DRIVERS" | wc -l)
      fi
      if [ $MULTIHEAD -gt 1 ]; then
        MULTIHEAD=yes
      fi
    fi
  else
    DISCOVERED_VIDEO=""
  fi
else
  DISCOVERED_VIDEO=""
fi
db_subst xserver-xorg/config/device/driver choices "$DISCOVERED_VIDEO"
auto_answer db_input low xserver-xorg/config/device/driver "$DISCOVERED_VIDEO"

if [ -n "$FIRSTINST" ] || [ -n "$RECONFIGURE" ]; then
  # BusID
  PRIORITY=low
  DEFAULT=

  # Some PowerPCs need to be told where to find the video card even if there is
  # only one in the machine (broken PCI bus code in the XFree86 X server, most
  # likely).  If there are multiple video cards, we need to configure one as the
  # primary head.
  if [ "$ARCH" = "powerpc" ] || [ "$MULTIHEAD" = "yes" ]; then
    PRIORITY=medium
    if which lspci > /dev/null 2>&1; then
      # Try to guess the correct BusID.
      VIDEO_CARD=$(LC_ALL=C lspci -n | grep -E "(Class )?0300:" | sort -n | head -n 1 \
        | cut -d\  -f1)
      if [ -n "$VIDEO_CARD" ]; then
        # Recent versions of lspci report a four-digit domain as the first field.
        if expr "$VIDEO_CARD" : ".*:.*:.*\..*" >/dev/null 2>&1; then
          # We have an entry in "hex:hex:hex.hex" format; we need
          # "PCI:decimal:decimal:decimal" (we don't use the domain).
          DOMAIN=$(printf "%d" 0x$(echo $VIDEO_CARD | cut -d: -f1) )
          BUS=$(printf "%d" 0x$(echo $VIDEO_CARD | cut -d: -f2) )
          DEVICE=$(printf "%d" 0x$(echo $VIDEO_CARD | cut -d: -f3 | cut -d. -f1) )
          FUNCTION=$(printf "%d" 0x$(echo $VIDEO_CARD | cut -d. -f2) )
          DEFAULT="PCI:$BUS:$DEVICE:$FUNCTION"
        elif expr "$VIDEO_CARD" : ".*:.*\..*" >/dev/null 2>&1; then
          # We have an entry in "hex:hex.hex" format; we need
          # "PCI:decimal:decimal:decimal".
          BUS=$(printf "%d" 0x$(echo $VIDEO_CARD | cut -d: -f1) )
          DEVICE=$(printf "%d" 0x$(echo $VIDEO_CARD | cut -d: -f2 | cut -d. -f1) )
          FUNCTION=$(printf "%d" 0x$(echo $VIDEO_CARD | cut -d. -f2) )
          DEFAULT="PCI:$BUS:$DEVICE:$FUNCTION"
        else
          warn "unrecognized output from lspci: \"$VIDEO_CARD\""
        fi
      fi
    fi
  fi

  # SGI Indigo2 XLs require a special hack, per Guido Guenther (see Debian
  # #249614).
  if [ -e /proc/cpuinfo ]; then
    if grep -q "system type.*:.*SGI Indigo2" /proc/cpuinfo; then
      PRIORITY=medium
      DEFAULT=1
    fi
  fi

  # For most people, asking this question at all is a bad idea. Only do it
  # if we have a need to do so, as defined by setting the priority
  if [ "$PRIORITY" = "medium" ]; then
    # this question requires input validation
    if [ -n "$DEFAULT" ]; then
      auto_answer validate_bus_id_db_input "$(priority_ceil $PRIORITY)" xserver-xorg/config/device/bus_id "$DEFAULT"
    else
      validate_bus_id_db_input "$(priority_ceil $PRIORITY)" xserver-xorg/config/device/bus_id || debug_report_status "validate_bus_id_db_input $(priority_ceil $PRIORITY) xserver-xorg/config/device/bus_id" "$?"
    fi
  else
    db_set xserver-xorg/config/device/bus_id ""
  fi

  # use fbcon kernel functions?

  case "$ARCH" in
    alpha|hurd-i386|i386|amd64)
      USE_FBDEV=false
      ;;
    *)
      USE_FBDEV=true
      ;;
  esac

  if [ -e /proc/fb ]; then
    FB_TYPE="$(grep '^0 ' /proc/fb | sed 's/[^[:space:]] //')"
    # did we actually get back anything?
    if [ -n "$FB_TYPE" ]; then
      if echo "$FB_TYPE" | grep -Eiq '(OFfb|VESA|VGA16)'; then
        USE_FBDEV=false
      else
        # other framebuffers do support UseFBDEV
        USE_FBDEV=true
      fi
    fi
  else
    USE_FBDEV=false
  fi

  if [ -n "$XORG_USE_FBDEV" ] && [ "$XORG_USE_FBDEV" = "no" ]; then
    USE_FBDEV=false
  fi

  db_get xserver-xorg/config/device/use_fbdev || debug_report_status "db_get xserver-xorg/config/device/use_fbdev"
  if [ "$RET" = "true" ] && [ "$USE_FBDEV" = "false" ]; then
    debug_echo "xserver-xorg/config/device/use_fbdev is \"true\" but /proc/fb does not exist, is empty, or reports a framebuffer type with which UseFBDev cannot be used; setting template to \"false\""
    db_set xserver-xorg/config/device/use_fbdev false
  fi

  auto_answer db_input "$(priority_ceil medium)" xserver-xorg/config/device/use_fbdev "$USE_FBDEV"
fi

# keyboard setup
PRIORITY="medium"

if [ -n "$FIRSTINST" ]; then
  AUTODETECT_KB="true"
else
  AUTODETECT_KB="false"
fi

auto_answer db_input "$(priority_ceil $PRIORITY)" xserver-xorg/autodetect_keyboard "$AUTODETECT_KB" || debug_echo "db_input xserver-xorg/autodetect_keyboard"
db_get xserver-xorg/autodetect_keyboard || debug_report_status "db_get server-xorg/autodetect_keyboard"
if [ "$RET" = "true" ]; then
  DOKBDETECT="true"
  debug_echo "Redetecting keyboard layout; resetting flag to false."
  db_set xserver-xorg/autodetect_keyboard false
fi

if [ -n "$DOKBDETECT" ] && [ -f /etc/default/console-setup ]; then
  # Hmm. At least for now, none of the variables in this file will clash
  # with our own variables ...
  . /etc/default/console-setup
fi

if [ "$XKBLAYOUT" ]; then
  debug_echo "Fetched keyboard layout from console configuration:"
  debug_echo "layout: '$XKBLAYOUT', options: '$XKBOPTIONS', variant: '$XKBVARIANT', model: '$XKBMODEL'"
  PRIORITY=low
elif [ -n "$DOKBDETECT" ]; then
  # generated by a small bit of Perl from a static list of keymaps provided
  # by Matthias Urlichs
  REALLANG=${LANG%%@*}
  REALLANG=${REALLANG%%.*}

  db_get debian-installer/keymap || debug_report_status "db_get debian-installer/keymap"
  DI_KEYMAP="${RET##mac-usb-}"
  DI_KEYMAP="${DI_KEYMAP%%-latin1}"

  case "$DI_KEYMAP" in
    be2) XMAP="be";;
    bg) XMAP="bg"; VARIANT="bds";;
    br) XMAP="us"; VARIANT="intl"; MODEL="pc104";;
    br-abnt2) XMAP="br"; VARIANT="abnt2"; MODEL="abnt2";;
    by) XMAP="by";;
    cf) XMAP="ca"; VARIANT="fr";;
    croat) XMAP="hr";;
    cz-lat2) XMAP="cz";;
    de-latin1-nodeadkeys) XMAP="de"; VARIANT="nodeadkeys";;
    de) XMAP="de";;
    dvorak) XMAP="us"; VARIANT="dvorak"; MODEL="pc104";;
    dk) XMAP="dk";;
    es) XMAP="es";;
    et) XMAP="ee";;
    fi) XMAP="fi";;
    fr) XMAP="fr"; VARIANT="oss";;
    fr_CH) XMAP="ch"; VARIANT="fr";;
    fr-latin9) XMAP="fr"; VARIANT="latin9";;
    gb) XMAP="gb";;
    gr) XMAP="gr";;
    hebrew) XMAP="il";;
    hu) XMAP="hu";;
    is) XMAP="is";;
    it) XMAP="it";;
    jp106) XMAP="jp"; MODEL="jp106";;
    la) XMAP="latam";;
    lfc-cat) XMAP="es"; VARIANT="cat";;
    lt) XMAP="lt";;
    lv-latin4) XMAP="lv";;
    # XXX should these be MODEL="macintosh"?
    mac-us-std) XMAP="us";;
    mac-de2-ext) XMAP="de"; VARIANT="nodeadkeys";;
    mac-fr2-ext) XMAP="fr";;
    mac-fr3) XMAP="fr";;
    mac-es) XMAP="es";;
    mac-usb-de_CH) XMAP="ch"; VARIANT="de";;
    mk) XMAP="mk";;
    nl) XMAP="nl";;
    no) XMAP="no";;
    pl) XMAP="pl";;
    pt) XMAP="pt";;
    ro) XMAP="ro";;
    ru) XMAP="ru";;
    se) XMAP="se";;
    sg) XMAP="ch"; VARIANT="de";;
    sk-qwerty) XMAP="sk"; VARIANT="qwerty";;
    slovene) XMAP="si";;
    sr-cy) XMAP="cs";;
    trf|trfu) XMAP="tr"; VARIANT="f";;
    trq|trqu) XMAP="tr";;
    ua) XMAP="ua";;
    uk) XMAP="gb";;
    us) XMAP="us"; MODEL="pc104";;
    *) XMAP="UNKNOWN";;
  esac

  if [ "$XMAP" = "us" ] && [ "${DI_LANG}" = "ko_KR" ]; then
    XMAP=kr # Uses US keyboard on the console.
    MODEL=
  fi

  if [ "$XMAP" = "UNKNOWN" ]; then
    warn "failed to infer keyboard layout from layout/lang '$DI_KEYMAP--$REALLANG'"
    PRIORITY=medium
    XMAP="us"
    MODEL="pc104"
  # prompt for layout if we ended up with French Canadian; apparently having
  # US-layout keyboards is common there
  elif [ "$XMAP" = "ca" ] && [ "$VARIANT" = "fr" ]; then
    PRIORITY=high
  else
    PRIORITY=low
  fi

  # we can't do non-Latin usernames, so people with Latin layouts need a US
  # layout so they can log in, and then switch to writing native text.  Bit hard
  # to work out which one should be the default.
  non_latin_keyboard
  if [ -n "$NON_LATIN" ]; then
    warn "selected layout '$XMAP' from '$DI_KEYMAP--$REALLANG' is non-Latin; " \
         "adding us to the layout list, Alt+Shift toggles"
    if [ -z "$OPTIONS" ]; then
      OPTIONS="grp:alt_shift_toggle"
    else
      OPTIONS="$OPTIONS,grp:alt_shift_toggle"
    fi
    XMAP="us,$XMAP"
  fi
  
  if [ -n "$LEVEL2" ]; then
    warn "selected layout '$XMAP' from '$DI_KEYMAP--$REALLANG' is l2-only"
  fi

  XKBLAYOUT="$XMAP"
  XKBOPTIONS="$OPTIONS"
  XKBVARIANT="$VARIANT"
  XKBMODEL="$MODEL"
else
  db_get xserver-xorg/config/inputdevice/keyboard/layout || debug_report_status "db_get xserver-xorg/config/inputdevice/keyboard/layout"
  XKBLAYOUT="$RET"
  db_get xserver-xorg/config/inputdevice/keyboard/options || debug_report_status "db_get xserver-xorg/config/inputdevice/keyboard/options"
  XKBOPTIONS="$RET"
  db_get xserver-xorg/config/inputdevice/keyboard/variant || debug_report_status "db_get xserver-xorg/config/inputdevice/keyboard/variant"
  XKBVARIANT="$RET"
  db_get xserver-xorg/config/inputdevice/keyboard/model || debug_report_status "db_get xserver-xorg/config/inputdevice/keyboard/model"
  XKBMODEL="$RET"
  PRIORITY=low
fi

MAY_BE_NULL= auto_answer validate_string_db_input "$(priority_ceil $PRIORITY)" xserver-xorg/config/inputdevice/keyboard/layout "$XKBLAYOUT"

# these questions require input validation
PRIORITY=medium

DEFAULT=xorg
MAY_BE_NULL= auto_answer validate_string_db_input "$(priority_ceil $PRIORITY)" xserver-xorg/config/inputdevice/keyboard/rules "$DEFAULT"

if [ -z "$XKBMODEL" ]; then
  db_get xserver-xorg/config/inputdevice/keyboard/rules
  if [ "$RET" = "sun" ]; then
    db_set xserver-xorg/config/inputdevice/keyboard/rules "xorg"
    XKBMODEL=pc105
  elif [ "$RET" = "xorg" ]; then
    if [ "$ARCH" = "powerpc" ] && \
        [ -e /proc/sys/dev/mac_hid/keyboard_sends_linux_keycodes ] && \
        [ "$(cat /proc/sys/dev/mac_hid/keyboard_sends_linux_keycodes)" = "0" ]; then
      XKBMODEL=macintosh_old
    else
      XKBMODEL=pc105
    fi
  fi
fi
MAY_BE_NULL= auto_answer validate_string_db_input "$(priority_ceil $PRIORITY)" xserver-xorg/config/inputdevice/keyboard/model "$XKBMODEL"

# ugly kludge, I know; map Apple->AltGr for most European Macs
db_get xserver-xorg/config/inputdevice/keyboard/model
if [ "$ARCH" = "powerpc" ] && [ "$RET" = "pc105" ]; then
  if [ -n "$XKBOPTIONS" ]; then
    if ! echo "$XKBOPTIONS" | grep -q "lv3:"; then
      XKBOPTIONS="$XKBOPTIONS,lv3:lwin_switch"
    fi
  else
    XKBOPTIONS="lv3:lwin_switch"
  fi
fi

# kill me now.
if echo "$XKBOPTIONS" | grep -q "nodeadkeys"; then
  if [ -z "$XKBVARIANT" ]; then
    XKBVARIANT="nodeadkeys"
    NEWOPTIONS=""
    IFS_SAVE="$IFS"
    IFS=","
    for i in $XKBOPTIONS; do
      IFS="$IFS_SAVE"
      if [ "$i" != "nodeadkeys" ]; then
        NEWOPTIONS="${NEWOPTIONS:+$NEWOPTIONS,}$i"
      fi
      IFS=","
    done
    IFS="$IFS_SAVE"
    XKBOPTIONS="$NEWOPTIONS"
    db_set xserver-xorg/config/inputdevice/keyboard/variant "$XKBVARIANT"
    db_set xserver-xorg/config/inputdevice/keyboard/options "$XKBOPTIONS"
  else
    warn "wanted to migrate nodeadkeys from options -> variant, but variant" \
         "is already $XKBVARIANT; not migrating"
  fi
fi

MAY_BE_NULL=yes auto_answer validate_string_db_input "$(priority_ceil low)" xserver-xorg/config/inputdevice/keyboard/variant "$XKBVARIANT"

MAY_BE_NULL=yes auto_answer validate_string_db_input "$(priority_ceil $PRIORITY)" xserver-xorg/config/inputdevice/keyboard/options "$XKBOPTIONS"


auto_answer db_input "$(priority_ceil low)" xserver-xorg/config/inputdevice/mouse/emulate3buttons true || debug_report_status "db_input $(priority_ceil low) xserver-xorg/config/inputdevice/mouse/emulate3buttons" "$?"
db_go

# files and dri sections
if [ -e "$CONFIG_AUX_DIR/.migrateconfig" ]; then
  AUTODETECT_VIDEO="yes"
  rm -f $CONFIG_AUX_DIR/.migrateconfig
fi

#DEBHELPER#

# register this package as a (potential) handler of the X server symlink and
# X.Org X server configuration file
for ROSTER in "$SERVER_SYMLINK_ROSTER" "$XORGCONFIG_ROSTER"; do
  if ! fgrep -qsx "$THIS_PACKAGE" "$ROSTER"; then
    echo "$THIS_PACKAGE" >> "$ROSTER"
  fi
done

# only mess with the server symlink file if it is a symbolic link or does
# not exist.  otherwise, assume that's the way the user wants it.
if ! [ -e "$SERVER_SYMLINK" ]; then
  ln -s "$THIS_SERVER" "$SERVER_SYMLINK"
# recover from an old bug
elif [ `readlink "$SERVER_SYMLINK"` = "/bin/true" ]; then
  rm -f "$SERVER_SYMLINK"
  ln -s "$THIS_SERVER" "$SERVER_SYMLINK"
fi

if [ -n "$UPGRADE" ] && dpkg --compare-versions "$2" le "1:7.3+5"; then
        # Clean up our old crap
        rm -f "$SERVER_SYMLINK_CHECKSUM" "$SERVER_SYMLINK_ROSTER"
        for QUESTION in "shared/default-x-server" \
                        "xserver-xorg/autodetect_mouse" \
                        "xserver-xorg/autodetect_monitor" \
                        "xserver-xorg/autodetect_video_card" \
                        "xserver-xorg/config/device/identifier" \
                        "xserver-xorg/config/monitor/selection-method" \
                        "xserver-xorg/config/monitor/screen-size" \
                        "xserver-xorg/config/monitor/mode-list" \
                        "xserver-xorg/config/monitor/default-identifier" \
                        "xserver-xorg/config/monitor/horiz-sync" \
                        "xserver-xorg/config/monitor/vert-refresh" \
                        "xserver-xorg/config/monitor/range_input_error" \
                        "xserver-xorg/config/display/modes" \
                        "xserver-xorg/config/device/video_ram" \
                        "xserver-xorg/config/display/default_depth" \
                        "xserver-xorg/config/inputdevice/mouse/port" \
                        "xserver-xorg/config/inputdevice/mouse/protocol" \
                        "xserver-xorg/config/modules" \
                        "xserver-xorg/config/monitor/default-identifier" \
                        "xserver-xorg/config/monitor/identifier" \
                        "xserver-xorg/config/write_files_section" \
                        "xserver-xorg/multiple_possible_x-drivers"; do
          db_unregister "$QUESTION" || true
        done
fi

# no debconf interaction should be done after this point
# (the dexconf call below invokes db_stop)

# Don't touch the config on upgrades except to deal with known issues with old
# configs.
if [ -z "$UPGRADE" ] || dpkg --compare-versions "$2" le "1:7.0.14"; then
  # compare the current and stored checksums; if they do not match, assume
  # that's the way the user wants it.  if we're reconfiguring, overwrite
  # it regardless and back it up.
  if [ "$(md5sum "$XORGCONFIG")" = "$(cat "$XORGCONFIG_CHECKSUM")" ] || \
     ! [ -e "$XORGCONFIG" ] || [ -n "$RECONFIGURE" ]; then
    # they match or user deleted the file or they're running dpkg-reconfigure; 
    # prepare a new version
    NEW_XORGCONFIG="$XORGCONFIG.dpkg-new"
    if [ -n "$RECONFIGURE" ] && [ -e "$XORGCONFIG" ]; then
      BACKUP_XORGCONFIG="$XORGCONFIG.$(date '+%Y%m%d%H%M%S')"
      if [ -e "$BACKUP_XORGCONFIG" ]; then
        bomb "backup xorg.conf file $BACKUP_XORGCONFIG already" \
             "exists; please remove it and try again"
      fi
      cp "$XORGCONFIG" "$BACKUP_XORGCONFIG"
      warn "overwriting possibly-customised configuration file; backup" \
           "in $BACKUP_XORGCONFIG"
    fi
    if dexconf -o "$NEW_XORGCONFIG"; then
      if ! cmp -s "$XORGCONFIG" "$NEW_XORGCONFIG"; then
        mv "$NEW_XORGCONFIG" "$XORGCONFIG"
        md5sum "$XORGCONFIG" > "$XORGCONFIG_CHECKSUM"
      fi
    else
      warn "error while preparing new Xorg X server configuration" \
           "file in $NEW_XORGCONFIG; not attempting to update existing" \
           "configuration"
    fi
    rm -f "$NEW_XORGCONFIG"
  else
    # I'm going to get in so much shit for this...
    BACKUP_XORGCONFIG="$XORGCONFIG.$(date '+%Y%m%d%H%M%S')"
    warn "$XORGCONFIG has been customized, but we need to make updates. Backing up your config to $BACKUP_XORGCONFIG. If we screw something up, restore using this file."
      cp "$XORGCONFIG" "$BACKUP_XORGCONFIG"
    sed -e'
	# Dump obsolete modules
	/^[[:space:]]*Section[[:space:]]\+"Module"[[:space:]]*$/,/^[[:space:]]*EndSection[[:space:]]*$/ { /^[[:space:]]*Load[[:space:]]\+"GLcore"[[:space:]]*$/d
		/^[[:space:]]*Load[[:space:]]\+"speedo"[[:space:]]*$/d
		/^[[:space:]]*Load[[:space:]]\+"type1"[[:space:]]*$/d
	}
	/^[[:space:]]*Section[[:space:]]\+"Files"[[:space:]]*$/,/*[[:space:]]*EndSection[[:space:]]*$/ {
		# Delete the module path
		/^[[:space:]]*ModulePath[[:space:]]\+/d
		# Delete the rgb path
		/^[[:space:]]*RgbPath[[:space:]]\+/d
		# Change font paths for the fonts xorg-x11 used to ship
		#/^[[:space:]]*FontPath[[:space:]]\+"\/usr\/share\/fonts\/X11\/misc"[[:space:]]*$/d
		#/^[[:space:]]*FontPath[[:space:]]\+"\/usr\/share\/fonts\/X11\/cyrillic"[[:space:]]*$/d
		#/^[[:space:]]*FontPath[[:space:]]\+"\/usr\/share\/fonts\/X11\/100dpi"[[:space:]]*$/d
		#/^[[:space:]]*FontPath[[:space:]]\+"\/usr\/share\/fonts\/X11\/75dpi"[[:space:]]*$/d
		#/^[[:space:]]*FontPath[[:space:]]\+"\/usr\/share\/fonts\/X11\/Type1"[[:space:]]*$/d
		#/^[[:space:]]*FontPath[[:space:]]\+"\/usr\/share\/fonts\/X11\/CID"[[:space:]]*$/d
		/^[[:space:]]*FontPath[[:space:]]\+"\/usr\/share\/fonts\/X11\/Speedo"[[:space:]]*$/d
		/^[[:space:]]*FontPath[[:space:]]\+"\/usr\/lib\/X11\/fonts\/misc"[[:space:]]*$/i\
	FontPath	"/usr/share/fonts/X11/misc"
		/^[[:space:]]*FontPath[[:space:]]\+"\/usr\/lib\/X11\/fonts\/cyrillic"[[:space:]]*$/i\
	FontPath	"/usr/share/fonts/X11/cyrillic"
		/^[[:space:]]*FontPath[[:space:]]\+"\/usr\/lib\/X11\/fonts\/100dpi"[[:space:]]*$/i\
	FontPath	"/usr/share/fonts/X11/100dpi"
		/^[[:space:]]*FontPath[[:space:]]\+"\/usr\/lib\/X11\/fonts\/75dpi"[[:space:]]*$/i\
	FontPath	"/usr/share/fonts/X11/75dpi"
		/^[[:space:]]*FontPath[[:space:]]\+"\/usr\/lib\/X11\/fonts\/Type1"[[:space:]]*$/i\
	FontPath	"/usr/share/fonts/X11/Type1"
		/^[[:space:]]*FontPath[[:space:]]\+"\/usr\/lib\/X11\/fonts\/CID"[[:space:]]*$/d
	}
	' $XORGCONFIG > ${XORGCONFIG}.madwizard-new
	chown --reference=$XORGCONFIG ${XORGCONFIG}.madwizard-new
	chmod --reference=$XORGCONFIG ${XORGCONFIG}.madwizard-new
	mv ${XORGCONFIG}.madwizard-new $XORGCONFIG
  fi
else
  debug_echo "not updating $XORGCONFIG; we're upgrading"
fi

exit 0

# vim:set ai et sts=2 sw=2 tw=0:
