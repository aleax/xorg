#!/bin/sh
# Debian xserver-xorg package post-installation script
# Copyright 1998-2004 Branden Robinson.
# Copyright 2004-2005 Canonical Ltd.
# Licensed under the GNU General Public License, version 2.  See the file
# /usr/share/common-licenses/GPL or <http://www.gnu.org/copyleft/gpl.txt>.
# Acknowledgements to Stephen Early, Mark Eichin, and Manoj Srivastava.

set -e

# source debconf library
. /usr/share/debconf/confmodule

THIS_PACKAGE=xserver-xorg
THIS_SCRIPT=postinst

LAPTOP=""
if [ -n "$(which laptop-detect)" ]; then
    if laptop-detect >/dev/null; then
	LAPTOP=true
    fi
fi

#INCLUDE_SHELL_LIB#

if [ -e /etc/default/xorg ]; then
  . /etc/default/xorg
fi

if [ "x$XORG_CONFIG" = "xcustom" ]; then
  # leave configuration alone
  warn "not updating configuration as per \$XORG_CUSTOM"
  exit 0
fi

# the error-out function
bomb () {
  echo "$PROGNAME: error: $*" | fold -s -w "${COLUMNS:-80}" >&2
  exit 1
}

debug_echo () {
  # Syntax: debug_echo message ...
  if [ -n "$DEBUG_XORG_DEBCONF" ] || [ "$DEBCONF_DEBUG" = "user" ] \
    || [ "$DEBCONF_DEBUG" = '.*' ]; then
    DEBUG_XORG_PACKAGE="yes" observe "$*"
  fi
}

validate_string_db_input () {
  # Syntax: validate_string_db_input priority template
  #
  # validate string input; can't have doublequotes
  # If $MAY_BE_NULL is a non-null value (e.g., "yes"), the string may be null.
  if [ $# -ne 2 ]; then
    echo "internal error: validate_string_db_input() called with wrong number of arguments: $*" >&2
    exit 1
  fi
  PRIORITY="$1"
  TEMPLATE="$2"
  db_get "$TEMPLATE"
  SAFE="$RET"
  set +e
  while :; do
    db_input "$PRIORITY" "$TEMPLATE"
    # is the question going to be asked?
    if [ $? -eq 30 ]; then
      break # no; bail out of validation loop
    fi
    db_go
    db_get "$TEMPLATE"
    if [ -n "$RET" ]; then
      if ! expr "$RET" : '.*".*' > /dev/null 2>&1; then
        break # valid input
      else
        ERROR="xserver-xorg/config/doublequote_in_string_error"
      fi
    else
      if [ -n "$MAY_BE_NULL" ]; then
        break # valid (null) input
      else
        ERROR="xserver-xorg/config/null_string_error"
      fi
    fi
    # we only get to this point if the input was invalid; restore the known
    # good value in case we are interrupted before the user provides a valid
    # one
    db_set "$TEMPLATE" "$SAFE"
    db_fset "$TEMPLATE" seen false
    # now show the user the error message
    db_fset "$ERROR" seen false
    db_input critical "$ERROR"
    db_go
  done
  set -e
}

validate_monitor_frequency_expr () {
  # syntax: validate_monitor_frequency_expr expression
  #
  # Confirm that the given expression is a valid monitor frequency expression
  # per xorg.conf(5).  Note that this does *not* handle (comma-delimited)
  # tuples.  We expect a single value or range with an optional unit suffix.
  #
  # Note: We don't check to see if the latter value in a range is actually
  # greater than the former, and we don't check to see if any of the numeric
  # values actually make sense.  I.e., 0 Hz may not actually be valid as far as
  # the X server is concerned, but 10000 Hz might be okay whereas 10000 kHz
  # might not be.  It would take quite a bit of code to sort all that out.  We
  # only take some of the bullets out of the user's gun -- not all of them.
  #
  # Return true (0) if the expression is valid, and false (1) if it is not.

  _func="validate_monitor_frequency_expr"

  # Validate function arguments.
  if [ $# -ne 1 ]; then
    internal_error "$_func(): called with wrong number of arguments; expected" \
                   "1, got $@"
  fi

  _regex='^[[:space:]]*0*[0-9]+(\.[0-9]+)?(-0*[0-9]+(\.[0-9]+)?)?([[:space:]]*[kM]?Hz)?$'

  if echo "$1" | grep -Eiq "$_regex"; then
    return 0
  else
    return 1
  fi
}

validate_monitor_frequency_db_input () {
  # syntax: validate_monitor_frequency_db_input priority template
  #
  # validate monitor frequency input

  _func="validate_monitor_frequency_db_input"

  # Validate function arguments.
  if [ $# -ne 2 ]; then
    internal_error "$_func(): called with wrong number of arguments; expected" \
                   "2, got $@"
  fi

  _priority=$1
  _template=$2
  db_get "$_template"
  _safe="$RET"
  set +e
  while :; do
    db_input "$_priority" "$_template"
    # is the question going to be asked?
    if [ $? -eq 30 ]; then
      break # no; bail out of validation loop
    fi
    db_go
    db_get "$_template"
    # This is a string, and needs input validation; a regex match will have to
    # do.  We force the first character to be a number to avoid hideous problems
    # in the debconf dialog frontend in 0.3.83 (it needs to be one anyway).  We
    # need to handle multiple expressions, delimited by commas.  See
    # xorg.conf(5) for more information.
    if expr "$RET" : ".*,.*" >/dev/null 2>&1; then
      _expr_is_valid=true
        echo "$RET" | tr -s ',' '\n' | while read _freq_expr; do
          if ! validate_monitor_frequency_expr "$_freq_expr"; then
            _expr_is_valid=
          fi
        done
        if [ -n "$_expr_is_valid" ]; then
          break
        fi
    else
      if validate_monitor_frequency_expr "$RET"; then
        break
      fi
    fi

    # we only get to this point if the input was invalid; restore the known
    # good value in case we are interrupted before the user provides a
    # valid one
    db_set "$_template" "$_safe"
    db_fset "$_template" seen false
    # now show the user the error message
    db_fset xserver-xorg/config/monitor/range_input_error seen false
    db_input critical xserver-xorg/config/monitor/range_input_error
    db_go
  done
  set -e
}

CONFIG_DIR="/etc/X11"
CONFIG_AUX_DIR=/var/lib/x11
SERVER_SYMLINK="$CONFIG_DIR/X"
XORGCONFIG="$CONFIG_DIR/xorg.conf"
CONFIG_AUX_DIR="/var/lib/x11"
SERVER_SYMLINK_CHECKSUM="$CONFIG_AUX_DIR/${SERVER_SYMLINK##*/}.md5sum"
SERVER_SYMLINK_ROSTER="$CONFIG_AUX_DIR/${SERVER_SYMLINK##*/}.roster"
XORGCONFIG_CHECKSUM="$CONFIG_AUX_DIR/${XORGCONFIG##*/}.md5sum"
XORGCONFIG_ROSTER="$CONFIG_AUX_DIR/${XORGCONFIG##*/}.roster"
THIS_SERVER=/usr/bin/Xorg

NCARDS=0
NSERVERS=0
NDRIVERS=0
MULTIHEAD=

# get machine architecture
ARCH=$(dpkg --print-installation-architecture)

debug_echo () {
  # Syntax: debug_echo message ...
  if [ -n "$DEBUG_XORG_DEBCONF" ] || [ "$DEBCONF_DEBUG" = "user" ] \
    || [ "$DEBCONF_DEBUG" = '.*' ]; then
    DEBUG_XORG_PACKAGE=yes observe "$*"
  fi
}

debug_report_status () {
  # Syntax: debug_report_status command exit_status
  debug_echo "$1 exited with status $2"
}

discover_sparc_video () {
  # Detect video cards on sparc by parsing prtconf output
  prtconf -p -v | awk '
  BEGIN {
          display_node = 0; 
          model = ""; 
          name = ""; 
  }
  /Node/ {
           if(display_node == 1) {
             printf "model=\"%s\" name=\"%s\"\n", model, name
             display_node = 0;
           };
           model = "";
           name = ""
  }
  /device_type:/ {
                   if(index($2, "display") != 0) {
                     display_node = 1
                   }
  }
  /model:/ { l=length($2); model = substr($2, 2, l-2) }
  /name:/  { l=length($2); name = substr($2, 2, l-2) }
  END{
       if(display_node == 1) {
         printf "model=\"%s\" name=\"%s\"\n", model, name
       }; 
  }' | \
  while read line
  do
    eval "${line}"
#   Match the name and the model to the driver.
    test -z "${name}" && continue
#   The model stored in the prom is usually not too
#   informative, so that we need to provide some
#   sensible human-readable card identification as well.
    server='XFree86'
    case "${name}" in
      'cgsix' )
        card='Sun CG6 framebuffer'
        driver='suncg6' 
	;;
      'SUNW,sx' )
        card='Sun CG14 framebuffer'
        driver='suncg14'
        ;;
      'SUNW,leo' )
        card='Sun LEO framebuffer'
        driver='sunleo'
        ;;
      'SUNW,tcx' )
        card='Sun TCX framebuffer' 
        driver='suntcx'
	;;
      'SUNW,m64B' )
        card='ATI Technologies 3D Rage Pro or similar'
        driver='ati'
        ;;
      'SUNW,ffb' )
        card='Sun Creator3D framebuffer or similar'
        driver='sunffb'
        ;;
      'SUNW,afb' )
        card='Sun Elite3D framebuffer or similar'
        driver='sunffb'
        ;;
      'TSI,gfxp' )
        card='PGX32 framebuffer or similar'
        driver='glint'
        ;;
      * )
        card='Unknown'
        server='unknown'
        driver='unknown'
        ;;
    esac
    if [ -n "${model}" ]; then
      card="${card} (${model})"
    fi
    echo -e "${card}\t${server}\t${driver}"
  done
}

discover_video () {
  # wrapper for discover command that can distinguish Discover 1.x and 2.x

  # Ugh, Discover 1.x didn't exit with nonzero status if given an unrecongized option!
  # Double ugh!  Discover is crashy.  People blame X when it crashes (but then,
  # people blame X when *anything* crashes).
  DISCOVER_ERRORFILE=$(tempfile)
  if DISCOVER_TEST=$(discover --version 2>>"$DISCOVER_ERRORFILE"); then
    if expr "$DISCOVER_TEST" : 'discover 2.*' > /dev/null 2>&1; then
      # Discover 2.x
      # XXX: this is sort of nasty
      VENDOR_MODEL_FILE=$(tempfile)
      SERVER_FILE=$(tempfile)
      DRIVER_FILE=$(tempfile)

      # Munge the source package version into the upstream version so we can
      # tell Discover what to look for.  Discover's data is based on the
      # upstream version number, not the Debian package's, so strip the Debian
      # revision and the (ugh!) epoch.  Note: do *not* do greedy matching.
      # Also, parameter expansions aren't nestable.  No respect, I tell ya.
      _JUNK=${SOURCE_VERSION%-*}
      UPSTREAM_VERSION=${_JUNK#*:}

      CMD="discover --type-summary display"
      eval $CMD >>$VENDOR_MODEL_FILE || debug_report_status "$CMD" "$?"
      CMD="discover --data-path=xfree86/server/name \
                    --data-version=$UPSTREAM_VERSION display"
      eval $CMD >>$SERVER_FILE || debug_report_status "$CMD" "$?"
      CMD="discover --data-path=xfree86/server/device/driver \
                    --data-version=$UPSTREAM_VERSION display"
      eval $CMD >>$DRIVER_FILE || debug_report_status "$CMD" "$?"

      DISCOVERED_VIDEO=$(paste $VENDOR_MODEL_FILE $SERVER_FILE $DRIVER_FILE)
      rm -f $VENDOR_MODEL_FILE $SERVER_FILE $DRIVER_FILE
    else
      # must be Discover 1.x
      DISCOVERED_VIDEO=$(discover --disable=serial,parallel,usb,ide,scsi \
                                  --format="%V %M\t%S\t%D\n" video 2>/dev/null)
    fi
    echo "$DISCOVERED_VIDEO"
  else
    warn "cannot use discover; failed with error message:" \
         "$(cat "$DISCOVER_ERRORFILE")"
  fi
  rm "$DISCOVER_ERRORFILE" || warn "discover error file never created, or" \
                                   "already removed"
}

validate_string_db_input () {
  # Syntax: validate_string_db_input priority template
  #
  # validate string input; can't have doublequotes
  # If $MAY_BE_NULL is a non-null value (e.g., "yes"), the string may be null.
  if [ $# -ne 2 ]; then
    echo "internal error: validate_string_db_input() called with wrong number of arguments: $*" >&2
    exit 1
  fi
  PRIORITY=$1
  TEMPLATE=$2
  db_get "$TEMPLATE"
  SAFE="$RET"
  set +e
  while :; do
    db_input "$PRIORITY" "$TEMPLATE"
    # is the question going to be asked?
    if [ $? -eq 30 ]; then
      break # no; bail out of validation loop
    fi
    db_go
    db_get "$TEMPLATE"
    if [ -n "$RET" ]; then
      if ! expr "$RET" : '.*".*' > /dev/null 2>&1; then
        break # valid input
      else
        ERROR=xserver-xorg/config/doublequote_in_string_error
      fi
    else
      if [ -n "$MAY_BE_NULL" ]; then
        break # valid (null) input
      else
        ERROR=xserver-xorg/config/null_string_error
      fi
    fi
    # we only get to this point if the input was invalid; restore the known
    # good value in case we are interrupted before the user provides a valid
    # one
    db_set "$TEMPLATE" "$SAFE"
    db_fset "$TEMPLATE" seen false
    # now show the user the error message
    db_fset "$ERROR" seen false
    db_input critical "$ERROR"
    db_go
  done
  set -e
}

validate_numeric_db_input () {
  # Syntax: validate_numeric_db_input priority template
  #
  # validate numeric input; must have only digits, can be null
  if [ $# -ne 2 ]; then
    echo "internal error: validate_numeric_db_input() called with wrong number of arguments: $*" >&2
    exit 1
  fi
  PRIORITY=$1
  TEMPLATE=$2
  db_get "$TEMPLATE"
  SAFE="$RET"
  set +e
  while :; do
    db_input "$PRIORITY" "$TEMPLATE"
    # is the question going to be asked?
    if [ $? -eq 30 ]; then
      break # no; bail out of validation loop
    fi
    db_go
    db_get "$TEMPLATE"
    if [ -z "$RET" ] || expr "$RET" : "[0-9]\+$" > /dev/null 2>&1; then
      break # valid input
    fi
    # we only get to this point if the input was invalid; restore the known
    # good value in case we are interrupted before the user provides a valid
    # one
    db_set "$TEMPLATE" "$SAFE"
    db_fset "$TEMPLATE" seen false
    # now show the user the error message
    db_fset xserver-xorg/config/nonnumeric_string_error seen false
    db_input critical xserver-xorg/config/nonnumeric_string_error
    db_go
  done
  set -e
}

validate_bus_id_db_input () {
  # Syntax: validate_bus_id_db_input priority template
  #
  # validate BusID input
  if [ $# -ne 2 ]; then
    echo "internal error: validate_bus_id_db_input() called with wrong number of arguments: $*" >&2
    exit 1
  fi
  PRIORITY=$1
  TEMPLATE=$2
  db_get "$TEMPLATE"
  SAFE="$RET"
  set +e
  while :; do
    db_input "$PRIORITY" "$TEMPLATE"
    # is the question going to be asked?
    if [ $? -eq 30 ]; then
      break # no; bail out of validation loop
    fi
    db_go
    db_get "$TEMPLATE"
    case "$RET" in
      "")
        # An empty string is valid.
        break
        ;;
      ISA:*)
        # Looks like an ISA bus ID specification string.  At least up to a
        # point; upstream (xf86ParseIsaBusString() in
        # xc/programs/Xserver/hw/xfree86/common/xf86isaBus.c) doesn't actually
        # *supply* a specification.  So if the user's gotten this far, it's good
        # enough.
        break
        ;;
      PCI:*)
        # Looks like a PCI bus ID specification; validate it.  (We can use &&
        # outside a conditional here because of the "set +e" above.)
        expr "$RET" : "PCI:[0-9]\{1,3\}:[0-9]\{1,3\}:[0-9]\{1,3\}$" >/dev/null \
          2>&1 && break
        ;;
      SBUS:*)
        # Looks like an SBUS bus ID specification; validate it.  (We can use &&
        # outside a conditional here because of the "set +e" above.)
        #
        # According to upstream (xf86ParseSbusBusString() in
        # xc/programs/Xserver/hw/xfree86/common/xf86sbusBus.c):
        #
        # The format is assumed to be one of:
        # * "fbN", e.g. "fb1", which means the device corresponding to /dev/fbN
        # * "nameN", e.g. "cgsix0", which means Nth instance of card NAME
        # * "/prompath", e.g. "/sbus@0,10001000/cgsix@3,0" which is
        #   PROM pathname to the device.
        #
        # Well, okay.
        #
        # Accept any non-null sequence of lowercase letters followed by a
        # non-null sequence of decimal digits.  This handles "fbN" and "nameN".
        expr "$RET" : "SBUS:[a-z]\+[0-9]\+" >/dev/null 2>&1 && break
        # Now for the PROM path.  I am lazy; accept a slash followed a non-null
        # sequence of letters and commas, an at sign, a non-null sequence of
        # hexadecimal digits, a comma, and another non-null sequence of
        # hexadecimal digits.  Furthermore, accept multiple occurences of this
        # entire sequence.  Whew.
        expr "$RET" : "SBUS:\(/[A-Za-z,]\+@[0-9A-Fa-f]\+,[0-9A-Fa-f]\+\)\+$" \
          >/dev/null 2>&1 && break
        ;;
      [0-9])
        # Accept a simple decimal integer for legacy buses that haven't been
        # properly implemented (e.g., for SGI Indigo2 XL).
        break
        ;;
      *)
    esac
    # we only get to this point if the input was invalid; restore the known good
    # value in case we are interrupted before the user provides a valid one
    db_set "$TEMPLATE" "$SAFE"
    db_fset "$TEMPLATE" seen false
    # now show the user the error message
    db_fset xserver-xorg/config/device/bus_id_error seen false
    db_input critical xserver-xorg/config/device/bus_id_error
    db_go
  done
  set -e
}

auto_answer () {
  # Syntax: auto_answer input_command priority template default_answer
  #
  # Used to auto-answer questions that don't have reasonable defaults.  Some
  # people insist on running the xserver-xorg config script with the
  # non-interactive frontend.  For this to work, the debconf database will need
  # to be pre-loaded with answers to several questions.  You have been
  # warned...
  if [ $# -ne 4 ]; then
    echo "internal error: auto_answer() called with wrong number of arguments: $*" >&2
    exit 1
  fi
  INPUT_COMMAND=$1
  PRIORITY=$2
  TEMPLATE=$3
  DEFAULT_ANSWER=$4
  set +e
  debug_echo "auto_answer() \"$INPUT_COMMAND $PRIORITY $TEMPLATE\" with default \"$DEFAULT_ANSWER\""
  db_fget "$TEMPLATE" seen
  # are we re-configuring?
  if [ -z "$FIRSTINST" ] && [ "$RET" = "true" ]; then
    # yes, we are reconfiguring
    db_get "$TEMPLATE"
    debug_echo "auto_answer: (reconfiguring) preserving existing answer \"$RET\""
  else
    # not reconfiguring; has the question been seen before?
    if [ "$RET" = "true" ]; then
      db_get "$TEMPLATE"
      debug_echo "auto_answer: (not reconfiguring) preserving existing answer \"$RET\""
    else
      debug_echo "auto_answer: auto-answering with \"$DEFAULT_ANSWER\""
      db_set $TEMPLATE "$DEFAULT_ANSWER"
    fi
  fi
  "$INPUT_COMMAND" "$PRIORITY" "$TEMPLATE"
  if [ $? -eq 30 ]; then
    debug_echo "auto_answer: $TEMPLATE is not being asked"
  else
    debug_echo "auto_answer: asking $TEMPLATE"
  fi
  set -e
  db_go
  db_get "$TEMPLATE"
  debug_echo "auto_answer: $TEMPLATE is \"$RET\""
}

priority_ceil() {
  # syntax: priority_ceil requested_priority
  #
  # Given a variable PRIORITY_CEILING and a "requested_priority" argument, echo
  # a debconf priority string corresponding to the lesser of the two.

  # Implementation note: a clever version of this could be done using "eval",
  # or embedding a Perl script, but those would be more difficult to maintain.
  # Better just to go the simple and stupid route.  Yes, I know this is not
  # very efficient.

  # Validate arguments.
  if [ $# -ne 1 ]; then
    debug_echo "priority_ceil() called with empty or bogus arguments \"$*\";" \
               "assuming argument of \"low\""
    _requested_priority=low
  else
    _requested_priority="$1"
  fi

  # If PRIORITY_CEILING is null or unset, it's same as not having one at all;
  # the sky's the limit.  We use a locally scoped priority_ceiling variable
  # because we don't want to affect the value of the global one.
  _priority_ceiling=${PRIORITY_CEILING:-"critical"}

  # Ensure the value of _priority_ceiling is reasonable.
  if [ "$_priority_ceiling" != "critical" ] && \
       [ "$_priority_ceiling" != "high" ] && \
       [ "$_priority_ceiling" != "medium" ] && \
       [ "$_priority_ceiling" != "low" ]; then
    debug_echo "priority_ceil() called with bogus value of \$PRIORITY_CEILING" \
               "\"$_priority_ceiling\"; treating as \"critical\""
    _priority_ceiling=critical
  fi

  case "$_requested_priority" in
    critical)
      # This is the highest priority, so there is nowhere to go but down.
      echo "$_priority_ceiling"
      ;;
    high)
      case "$_priority_ceiling" in
        critical)
          echo "$_requested_priority"
          ;;
        high|medium|low)
          echo "$_priority_ceiling"
          ;;
      esac
      ;;
    medium)
      case "$_priority_ceiling" in
        critical|high)
          echo "$_requested_priority"
          ;;
        medium|low)
          echo "$_priority_ceiling"
          ;;
      esac
      ;;
    low)
      # This is the lowest priority, so we can't go any lower.
      echo "$_requested_priority"
      ;;
    *)
      debug_echo "priority_ceil() called with bogus argument" \
                 "\"$_requested_priority\"; returning \"low\""
      echo low
      ;;
  esac
}

non_latin_keyboard () {
  NONLATINMAPS="am ar bg by cs el gr il ir iu lo lt mk ml mm mn ru th tj ua"
  for i in $NONLATINMAPS; do
    if [ "$XMAP" = "$i" ]; then
      NON_LATIN="true"
    fi
  done

  # Turkish F keyboards are non-Latin; Turkish Q aren't.
  if [ "$XMAP" = "tr" ] && [ "$VARIANT" = "f" ]; then
    NON_LATIN="true"
  fi
}

# analyze arguments; used by auto_answer()
if [ "$1" = "reconfigure" ] || [ -n "$DEBCONF_RECONFIGURE" ]; then
  RECONFIGURE=true
else
  RECONFIGURE=
fi

if [ -z "$2" ]; then
  FIRSTINST=yes
fi

# The only supported protocol (per Zephaniah Hull) for the GPM repeater is
# IntelliMouse; migrate anyone using that mouse device to that protocol.  Other
# values used to work as well, but no longer do since the XFree86 mouse driver
# was rewritten for XFree86 4.3.0.  See Debian bug #233933 for more details.
db_get xserver-xorg/config/inputdevice/mouse/port
if [ "$RET" = "/dev/gpmdata" ]; then
  db_get xserver-xorg/config/inputdevice/mouse/protocol
  if [ "$RET" != "IntelliMouse" ]; then
    observe "migrating template" \
            "\"xserver-xorg/config/inputdevice/mouse/protocol\" from" \
            "\"$RET\" to \"IntelliMouse\""
    db_set xserver-xorg/config/inputdevice/mouse/protocol "IntelliMouse"
  fi
fi

debug_echo "Configuring $THIS_PACKAGE."

# default X server

# if the X server symlink file already exists and points to an executable X
# server, it's not as important to ask questions related to it (these questions
# "have a reasonable default")
PRIORITY_CEILING=
if [ -e "$SERVER_SYMLINK" ]; then
  if [ -x "$(readlink "$SERVER_SYMLINK")" ]; then
    debug_echo "X server symlink exists and points to executable X server;" \
               "capping X server question priority at medium."
    PRIORITY_CEILING=medium
  fi
fi

# priority of shared/default-x-server
PRIORITY=high

db_metaget shared/default-x-server owners
OWNERS="$RET"
db_metaget shared/default-x-server choices
CHOICES="$RET"

if [ "$OWNERS" != "$CHOICES" ]; then
  debug_echo "\$OWNERS does not equal \$CHOICES: \"$OWNERS\" != \"$CHOICES\""
  db_subst shared/default-x-server choices $OWNERS
  db_fset shared/default-x-server seen false
fi

if ! expr "$OWNERS" : ".*,.*" > /dev/null 2>&1; then
  debug_echo "\$OWNERS has only one value; shared/default-x-server will not be asked"
fi

# collect information about installed video card(s), if possible
case "$ARCH" in
  sparc)
    DISCOVER_PROG='prtconf'
    DISCOVER_FUNC='discover_sparc_video'
    ;;
  *)
    DISCOVER_PROG='discover'
    DISCOVER_FUNC='discover_video'
    ;;
esac
if which $DISCOVER_PROG > /dev/null 2>&1; then
  DISCOVERED_VIDEO=$($DISCOVER_FUNC)
  MULTIHEAD=$(echo "$DISCOVERED_VIDEO" | wc -l)
  DISCOVERED_VIDEO=$(echo "$DISCOVERED_VIDEO" | head -n 1)
  if [ -n "$DISCOVERED_VIDEO" ]; then
    NCARDS=$(echo "$DISCOVERED_VIDEO" | wc -l)
    SERVERS=$(echo "$DISCOVERED_VIDEO" | awk 'BEGIN { FS="\t" } {print $2}' | grep -v unknown | sort | uniq)
    if [ -n "$SERVERS" ]; then
      NSERVERS=$(echo "$SERVERS" | wc -l)
    fi
    DRIVERS=$(echo "$DISCOVERED_VIDEO" | awk 'BEGIN { FS="\t" } {print $NF}' | grep -v unknown | sort | uniq)
    if [ -n "$DRIVERS" ]; then
      NDRIVERS=$(echo "$DRIVERS" | wc -l)
    fi
    if [ $MULTIHEAD -gt 1 ]; then
      MULTIHEAD=yes
    fi
  fi
fi

if [ -n "$FIRSTINST" ] || [ -n "$RECONFIGURE" ]; then
  if which $DISCOVER_PROG > /dev/null 2>&1; then
    PRIORITY="medium"
    if [ -n "$RECONFIGURE" ]; then
      PRIORITY="high"
    fi
    auto_answer db_input "$(priority_ceil $PRIORITY)" xserver-xorg/autodetect_video_card "true"
    db_get xserver-xorg/autodetect_video_card
    AUTODETECT_VIDEO_CARD="$RET"
    if [ "$AUTODETECT_VIDEO_CARD" = "true" ]; then
      # We're going to autodetect, so clear out the old values
      for param in use_fbdev driver video_ram identifier bus_id; do
          db_reset xserver-xorg/config/device/$param
      done

      # priority of xserver-xorg/config/device/driver
      PRIORITY=medium
      if [ -n "$RECONFIGURE" ]; then
        PRIORITY=high
      fi

      DRIVER_DIRS="/usr/lib/xorg/modules/drivers"
      for i in $DRIVER_DIRS; do
        if [ -d $i ]; then
          REAL_DRIVER_DIRS="$REAL_DRIVER_DIRS $i "
        fi
      done

      if [ -n "$REAL_DRIVER_DIRS" ]; then
        # Build list of available video drivers, omitting the atimisc, r128, and
        # radeon sub-modules (the ati driver knows when and how to load these).
        # v4l is not a display driver, and dummy is for advanced users.
        DRIVER_LIST="$(find $REAL_DRIVER_DIRS -name '*_drv.*' \
                       | sed 's|^.*/\([^/]*\)_drv\.[^\._]*|\1|g' \
                       | egrep -v '(atimisc|dummy|r128|radeon|v4l)' | sort -u | xargs \
                       | sed 's/ /, /g' 2>/dev/null) "
      fi

      # Set a hard-coded module list (if necessary) and default driver module on an
      # architecture-specific basis.
      case "$ARCH" in
        alpha)
          DEFAULT_DRIVER=vga
          ;;
        amd64|hurd-i386|i386)
          DEFAULT_DRIVER=vesa
          ;;
        sparc)
          DEFAULT_DRIVER=sunffb
          ;;
        *)
          DEFAULT_DRIVER=fbdev
          ;;
      esac

      if [ -z "$DRIVER_LIST" ]; then
        observe "no video driver modules found in $DRIVER_DIRS; defaulting to $DEFAULT_DRIVER"
        DRIVER_LIST="$DEFAULT_DRIVER"
      fi

      observe "available video driver list set to \"$DRIVER_LIST\""

      if [ $NDRIVERS -eq 0 ]; then
        observe "could not autodetect X server driver: no video card" \
                "detected, or no driver known for it"
      elif [ $NDRIVERS -eq 1 ]; then
        observe "autodetected X server driver: $DRIVERS"
        PRIORITY=low
        DEFAULT_DRIVER="$DRIVERS"
      elif [ $NDRIVERS -gt 1 ]; then
        observe "could not autodetect X server driver: multiple drivers for" \
                "video cards"
        VIDEOCARD_DRIVER_REPORT=$(echo "$DISCOVERED_VIDEO" \
          | awk 'BEGIN { FS="\t"; printf " %-30s%30s\n .\n", "Detected Video Card", "Suggested driver module" } { printf " %-50s%10s\n", $1, $3 } END { printf " .\n" }')
        # can't do this until there is a way to embed newlines into debconf
        # command streams :(
        # db_subst shared/multiple_possible_x-drivers detected_cards \
        #   "$VIDEOCARD_DRIVER_REPORT"
        observe "$VIDEOCARD_DRIVER_REPORT"
        PRIORITY=high
        db_input "$(priority_ceil high)" xserver-xorg/multiple_possible_x-drivers || debug_report_status "db_input $(priority_ceil high) xserver-xorg/multiple_possible_x-drivers" "$?"
        db_go
      fi
    else
      observe "user declined video card autodetection (driver)"
    fi
  else
    observe "could not autodetect X server driver: $DISCOVER_PROG not found"
  fi

  db_subst xserver-xorg/config/device/driver choices "$DRIVER_LIST"
  auto_answer db_input "$PRIORITY" \
    xserver-xorg/config/device/driver "$DEFAULT_DRIVER"

  # card identifier; try to set a sensible default
  DEFAULT=
  if [ -n "$(echo $NDRIVERS)" ] && [ $NDRIVERS -eq 1 ] && [ $NCARDS -eq 1 ]; then
    if which $DISCOVER_PROG > /dev/null 2>&1; then
      if [ "$AUTODETECT_VIDEO_CARD" = "true" ]; then
        DEFAULT=$(echo "$DISCOVERED_VIDEO" | awk 'BEGIN { FS="\t" } {print $1}')
      fi
    fi
  fi
  if [ -z "$DEFAULT" ]; then
    # fall back to some language-specific generic text
    db_metaget xserver-xorg/config/device/default-identifier Description
    DEFAULT=$RET
  fi
  # this question requires input validation
  MAY_BE_NULL= auto_answer validate_string_db_input "$(priority_ceil low)" xserver-xorg/config/device/identifier "$DEFAULT"

  DEVICE_IDENTIFIER="$DEFAULT"

  # BusID
  PRIORITY=low
  DEFAULT=

  # Some PowerPCs need to be told where to find the video card even if there is
  # only one in the machine (broken PCI bus code in the XFree86 X server, most
  # likely).  If there are multiple video cards, we need to configure one as the
  # primary head.
  # Warty: always feed this info.
  MULTIHEAD=yes
  if [ "$ARCH" = "powerpc" ] || [ "$MULTIHEAD" = "yes" ]; then
    if [ "$ARCH" = "powerpc" ]; then
      PRIORITY=medium
    fi
    if [ "$MULTIHEAD" = "yes" ]; then
      PRIORITY=medium
    fi
    if which lspci > /dev/null 2>&1; then
      # Try to guess the correct BusID.
      VIDEO_CARD=$(LC_ALL=C lspci -n | grep -E "(Class )?0300:" | sort -n | head -n 1 \
        | cut -d\  -f1)
      if [ -n "$VIDEO_CARD" ]; then
        # Recent versions of lspci report a four-digit domain as the first field.
        if expr "$VIDEO_CARD" : ".*:.*:.*\..*" >/dev/null 2>&1; then
          # We have an entry in "hex:hex:hex.hex" format; we need
          # "PCI:decimal:decimal:decimal" (we don't use the domain).
          DOMAIN=$(printf "%d" 0x$(echo $VIDEO_CARD | cut -d: -f1) )
          BUS=$(printf "%d" 0x$(echo $VIDEO_CARD | cut -d: -f2) )
          DEVICE=$(printf "%d" 0x$(echo $VIDEO_CARD | cut -d: -f3 | cut -d. -f1) )
          FUNCTION=$(printf "%d" 0x$(echo $VIDEO_CARD | cut -d. -f2) )
          DEFAULT="PCI:$BUS:$DEVICE:$FUNCTION"
        elif expr "$VIDEO_CARD" : ".*:.*\..*" >/dev/null 2>&1; then
          # We have an entry in "hex:hex.hex" format; we need
          # "PCI:decimal:decimal:decimal".
          BUS=$(printf "%d" 0x$(echo $VIDEO_CARD | cut -d: -f1) )
          DEVICE=$(printf "%d" 0x$(echo $VIDEO_CARD | cut -d: -f2 | cut -d. -f1) )
          FUNCTION=$(printf "%d" 0x$(echo $VIDEO_CARD | cut -d. -f2) )
          DEFAULT="PCI:$BUS:$DEVICE:$FUNCTION"
        else
          warn "unrecognized output from lspci: \"$VIDEO_CARD\""
        fi
      fi
    fi
  fi

  # SGI Indigo2 XLs require a special hack, per Guido Guenther (see Debian
  # #249614).
  if [ -e /proc/cpuinfo ]; then
    if grep -q "system type.*:.*SGI Indigo2" /proc/cpuinfo; then
      PRIORITY=medium
      DEFAULT=1
    fi
  fi

  # this question requires input validation
  if [ -n "$DEFAULT" ]; then
    auto_answer validate_bus_id_db_input "$(priority_ceil $PRIORITY)" xserver-xorg/config/device/bus_id "$DEFAULT"
  else
    validate_bus_id_db_input "$(priority_ceil $PRIORITY)" xserver-xorg/config/device/bus_id || debug_report_status "validate_bus_id_db_input $(priority_ceil $PRIORITY) xserver-xorg/config/device/bus_id" "$?"
  fi

  # video RAM
  db_get xserver-xorg/config/device/driver
  DEFAULT=
  # this question requires input validation
  if [ -n "$DEFAULT" ]; then
    auto_answer validate_numeric_db_input "$(priority_ceil low)" xserver-xorg/config/device/video_ram "$DEFAULT"
  else
    validate_numeric_db_input "$(priority_ceil low)" xserver-xorg/config/device/video_ram || debug_report_status "validate_numeric_db_input $(priority_ceil low) xserver-xorg/config/device/video_ram" "$?"
  fi

  # use fbcon kernel functions?

  case "$ARCH" in
    alpha|hurd-i386|i386|amd64)
      USE_FBDEV=false
      ;;
    *)
      USE_FBDEV=true
      ;;
  esac

  if [ -e /proc/fb ]; then
    FB_TYPE="$(grep '^0 ' /proc/fb | sed 's/[^[:space:]] //')"
    # did we actually get back anything?
    if [ -n "$FB_TYPE" ]; then
      if echo "$FB_TYPE" | grep -Eiq '(OFfb|VESA|VGA16)'; then
        USE_FBDEV=false
      else
        # other framebuffers do support UseFBDEV
        USE_FBDEV=true
      fi
    fi
  else
    USE_FBDEV=false
  fi

  # it looks like Mac Mini need an extra kick. Make sure to give it to it.
 
  if [ "$ARCH" = powerpc ] && [ "$USE_FBDEV" = "false" ]; then
    # it looks like Mac Mini need an extra kick. Make sure to give it to it.
    if [ -e /proc/cpuinfo ]; then
      if [ -n "$(cat /proc/cpuinfo | grep "^machine.*PowerMac10,1")" ] && \
         [ -n "$(cat /proc/cpuinfo | grep "^platform.*PowerMac")" ]; then
        USE_FBDEV=true
      fi
    fi
    # Make sure to force UseFBDev with Rage 128 or stuff will go bad in some
    # old Macs.
    if echo "$DEVICE_IDENTIFIER" | grep -q "Rage 128"; then
      USE_FBDEV=true
    fi
  fi

  if [ -n "$XORG_USE_FBDEV" ] && [ "$XORG_USE_FBDEV" = "no" ]; then
    USE_FBDEV=false
  fi

  db_get xserver-xorg/config/device/use_fbdev || debug_report_status "db_get xserver-xorg/config/device/use_fbdev"
  if [ "$RET" = "true" ] && [ "$USE_FBDEV" = "false" ]; then
    debug_echo "xserver-xorg/config/device/use_fbdev is \"true\" but /proc/fb does not exist, is empty, or reports a framebuffer type with which UseFBDev cannot be used; setting template to \"false\""
    db_set xserver-xorg/config/device/use_fbdev false
  fi

  auto_answer db_input "$(priority_ceil medium)" xserver-xorg/config/device/use_fbdev "$USE_FBDEV"
fi

# keyboard setup
PRIORITY="medium"

if [ -n "$FIRSTINST" ]; then
  AUTODETECT_KB="true"
else
  AUTODETECT_KB="false"
fi

auto_answer db_input "$(priority_ceil $PRIORITY)" xserver-xorg/autodetect_keyboard "$AUTODETECT_KB" || debug_echo "db_input xserver-xorg/autodetect_keyboard"
db_get xserver-xorg/autodetect_keyboard || debug_report_status "db_get server-xorg/autodetect_keyboard"
if [ "$RET" = "true" ]; then
  DOKBDETECT="true"
  debug_echo "Redetecting keyboard layout; resetting flag to false."
  db_set xserver-xorg/autodetect_keyboard false
fi

if [ -n "$DOKBDETECT" ]; then
  # generated by a small bit of Perl from a static list of keymaps provided
  # by Matthias Urlichs
  REALLANG=${LANG%%@*}
  REALLANG=${REALLANG%%.*}

  db_get debian-installer/keymap || debug_report_status "db_get debian-installer/keymap"
  DI_KEYMAP="${RET##mac-usb-}"
  DI_KEYMAP="${DI_KEYMAP%%-latin1}"

  case "$DI_KEYMAP" in
    be2) XMAP="be";;
    bg) XMAP="bg"; VARIANT="bds";;
    br) XMAP="us"; VARIANT="intl"; MODEL="pc104";;
    br-abnt2) XMAP="br"; VARIANT="abnt2"; MODEL="abnt2";;
    by) XMAP="by";;
    cf) XMAP="ca"; VARIANT="fr";;
    croat) XMAP="hr";;
    cz-lat2) XMAP="cz";;
    de-latin1-nodeadkeys) XMAP="de"; VARIANT="nodeadkeys";;
    de) XMAP="de";;
    dvorak) XMAP="us"; VARIANT="dvorak"; MODEL="pc104";;
    dk) XMAP="dk";;
    es) XMAP="es";;
    et) XMAP="ee";;
    fi) XMAP="fi";;
    fr) XMAP="fr"; VARIANT="oss";;
    fr_CH) XMAP="ch"; VARIANT="fr";;
    fr-latin9) XMAP="fr"; VARIANT="latin9";;
    gb) XMAP="gb";;
    gr) XMAP="gr";;
    hebrew) XMAP="il";;
    hu) XMAP="hu";;
    is) XMAP="is";;
    it) XMAP="it";;
    jp106) XMAP="jp"; MODEL="jp106";;
    la) XMAP="latam";;
    lfc-cat) XMAP="es"; VARIANT="cat";;
    lt) XMAP="lt";;
    lv-latin4) XMAP="lv";;
    # XXX should these be MODEL="macintosh"?
    mac-us-std) XMAP="us";;
    mac-de2-ext) XMAP="de"; VARIANT="nodeadkeys";;
    mac-fr2-ext) XMAP="fr";;
    mac-fr3) XMAP="fr";;
    mac-es) XMAP="es";;
    mac-usb-de_CH) XMAP="ch"; VARIANT="de";;
    mk) XMAP="mk";;
    nl) XMAP="nl";;
    no) XMAP="no";;
    pl) XMAP="pl";;
    pt) XMAP="pt";;
    ro) XMAP="ro";;
    ru) XMAP="ru";;
    se) XMAP="se";;
    sg) XMAP="ch"; VARIANT="de";;
    sk-qwerty) XMAP="sk"; VARIANT="qwerty";;
    slovene) XMAP="si";;
    sr-cy) XMAP="cs";;
    trf|trfu) XMAP="tr"; VARIANT="f";;
    trq|trqu) XMAP="tr";;
    ua) XMAP="ua";;
    uk) XMAP="gb";;
    us) XMAP="us"; MODEL="pc104";;
    *) XMAP="UNKNOWN";;
  esac

  if [ "$XMAP" = "UNKNOWN" ]; then
    warn "failed to infer keyboard layout from layout/lang '$DI_KEYMAP--$REALLANG'"
    PRIORITY=medium
    XMAP="us"
    MODEL="pc104"
  # prompt for layout if we ended up with French Canadian; apparently having
  # US-layout keyboards is common there
  elif [ "$XMAP" = "ca" ] && [ "$VARIANT" = "fr" ]; then
    PRIORITY=high
  else
    PRIORITY=low
  fi

  # we can't do non-Latin usernames, so people with Latin layouts need a US
  # layout so they can log in, and then switch to writing native text.  Bit hard
  # to work out which one should be the default.
  non_latin_keyboard
  if [ -n "$NON_LATIN" ]; then
    warn "selected layout '$XMAP' from '$DI_KEYMAP--$REALLANG' is non-Latin; " \
         "adding us to the layout list, Alt+Shift toggles"
    if [ -z "$OPTIONS" ]; then
      OPTIONS="grp:alt_shift_toggle"
    else
      OPTIONS="$OPTIONS,grp:alt_shift_toggle"
    fi
    XMAP="us,$XMAP"
  fi
  
  if [ -n "$LEVEL2" ]; then
    warn "selected layout '$XMAP' from '$DI_KEYMAP--$REALLANG' is l2-only"
  fi

  XKBLAYOUT="$XMAP"
  XKBOPTIONS="$OPTIONS"
  XKBVARIANT="$VARIANT"
  XKBMODEL="$MODEL"
else
  db_get xserver-xorg/config/inputdevice/keyboard/layout || debug_report_status "db_get xserver-xorg/config/inputdevice/keyboard/layout"
  XKBLAYOUT="$RET"
  db_get xserver-xorg/config/inputdevice/keyboard/options || debug_report_status "db_get xserver-xorg/config/inputdevice/keyboard/options"
  XKBOPTIONS="$RET"
  db_get xserver-xorg/config/inputdevice/keyboard/variant || debug_report_status "db_get xserver-xorg/config/inputdevice/keyboard/variant"
  XKBVARIANT="$RET"
  db_get xserver-xorg/config/inputdevice/keyboard/model || debug_report_status "db_get xserver-xorg/config/inputdevice/keyboard/model"
  XKBMODEL="$RET"
  PRIORITY=low
fi

MAY_BE_NULL= auto_answer validate_string_db_input "$(priority_ceil $PRIORITY)" xserver-xorg/config/inputdevice/keyboard/layout "$XKBLAYOUT"

# these questions require input validation
PRIORITY=medium

DEFAULT=xorg
MAY_BE_NULL= auto_answer validate_string_db_input "$(priority_ceil $PRIORITY)" xserver-xorg/config/inputdevice/keyboard/rules "$DEFAULT"

if [ -z "$XKBMODEL" ]; then
  db_get xserver-xorg/config/inputdevice/keyboard/rules
  if [ "$RET" = "sun" ]; then
    XKBMODEL=type5
  elif [ "$RET" = "xorg" ]; then
    if [ "$ARCH" = "powerpc" ] && \
        [ -e /proc/sys/dev/mac_hid/keyboard_sends_linux_keycodes ] && \
        [ "$(cat /proc/sys/dev/mac_hid/keyboard_sends_linux_keycodes)" = "0" ]; then
      XKBMODEL=macintosh_old
    else
      XKBMODEL=pc105
    fi
  fi
fi
MAY_BE_NULL= auto_answer validate_string_db_input "$(priority_ceil $PRIORITY)" xserver-xorg/config/inputdevice/keyboard/model "$XKBMODEL"

# ugly kludge, I know; map Apple->AltGr for most European Macs
db_get xserver-xorg/config/inputdevice/keyboard/model
if [ "$ARCH" = "powerpc" ] && [ "$RET" = "pc105" ]; then
  if [ -n "$XKBOPTIONS" ]; then
    if ! echo "$XKBOPTIONS" | grep -q "lv3:"; then
      XKBOPTIONS="$XKBOPTIONS,lv3:lwin_switch"
    fi
  else
    XKBOPTIONS="lv3:lwin_switch"
  fi
fi

# kill me now.
if echo "$XKBOPTIONS" | grep -q "nodeadkeys"; then
  if [ -z "$XKBVARIANT" ]; then
    XKBVARIANT="nodeadkeys"
    NEWOPTIONS=""
    IFS_SAVE="$IFS"
    IFS=","
    for i in $XKBOPTIONS; do
      IFS="$IFS_SAVE"
      if [ "$i" != "nodeadkeys" ]; then
        NEWOPTIONS="${NEWOPTIONS:+$NEWOPTIONS,}$i"
      fi
      IFS=","
    done
    IFS="$IFS_SAVE"
    XKBOPTIONS="$NEWOPTIONS"
    db_set xserver-xorg/config/inputdevice/keyboard/variant "$XKBVARIANT"
    db_set xserver-xorg/config/inputdevice/keyboard/options "$XKBOPTIONS"
  else
    warn "wanted to migrate nodeadkeys from options -> variant, but variant" \
         "is already $XKBVARIANT; not migrating"
  fi
fi

MAY_BE_NULL=yes auto_answer validate_string_db_input "$(priority_ceil low)" xserver-xorg/config/inputdevice/keyboard/variant "$XKBVARIANT"

MAY_BE_NULL=yes auto_answer validate_string_db_input "$(priority_ceil $PRIORITY)" xserver-xorg/config/inputdevice/keyboard/options "$XKBOPTIONS"

auto_answer db_input "$(priority_ceil low)" xserver-xorg/config/inputdevice/mouse/port "/dev/input/mice"

db_get xserver-xorg/config/inputdevice/mouse/port
case "$RET" in
  *psaux)
    MOUSE_PROTOCOL_CHOICES="PS/2, ImPS/2, GlidePointPS/2, NetMousePS/2, NetScrollPS/2, ThinkingMousePS/2, MouseManPlusPS/2, ExplorerPS/2"
    DEFAULT_PROTOCOL="PS/2"
    ;;
  *ttyS*|*tts/*)
    MOUSE_PROTOCOL_CHOICES="Auto, Microsoft, MouseSystems, GlidePoint, ThinkingMouse, ValuMouseScroll, MouseMan, Logitech, IntelliMouse, MMSeries, MMHitTab"
    DEFAULT_PROTOCOL="Auto"
    ;;
  *input/mice)
    MOUSE_PROTOCOL_CHOICES="ImPS/2, ExplorerPS/2"
    DEFAULT_PROTOCOL="ImPS/2"
    ;;
  *atibm|*atixl|*sunmouse)
    MOUSE_PROTOCOL_CHOICES="BusMouse"
    DEFAULT_PROTOCOL="BusMouse"
    ;;
  *gpmdata)
    MOUSE_PROTOCOL_CHOICES="IntelliMouse"
    DEFAULT_PROTOCOL="IntelliMouse"
    ;;
esac
db_subst xserver-xorg/config/inputdevice/mouse/protocol choices $MOUSE_PROTOCOL_CHOICES
if ! expr "$MOUSE_PROTOCOL_CHOICES" : ".*,.*" > /dev/null 2>&1; then
  debug_echo "\$MOUSE_PROTOCOL_CHOICES has only one value; setting xserver-xorg/config/inputdevice/mouse/protocol to \"$DEFAULT_PROTOCOL\""
  db_set xserver-xorg/config/inputdevice/mouse/protocol "$DEFAULT_PROTOCOL"
else
  auto_answer db_input "$(priority_ceil $PRIORITY)" xserver-xorg/config/inputdevice/mouse/protocol "${AUTODETECTED_PROTOCOL:-$DEFAULT_PROTOCOL}"
fi

auto_answer db_input "$(priority_ceil low)" xserver-xorg/config/inputdevice/mouse/emulate3buttons true || debug_report_status "db_input $(priority_ceil low) xserver-xorg/config/inputdevice/mouse/emulate3buttons" "$?"
db_go

# files and dri sections
auto_answer db_input "$(priority_ceil low)" xserver-xorg/config/write_files_section true || debug_report_status "db_input $(priority_ceil low) xserver-xorg/config/write_files_section" "$?"
db_go
if [ -e "$CONFIG_AUX_DIR/.migrateconfig" ]; then
  AUTODETECT_VIDEO="yes"
  rm -f $CONFIG_AUX_DIR/.migrateconfig
fi

if [ -n "$DEBUG_XORG_PACKAGE" ]; then
  XRESPROBE_DEBUG="yes"
fi

#DEBHELPER#

xresprobeint() {
  PRIORITY="medium"
  db_input $PRIORITY xserver-xorg/autodetect_monitor || debug_echo "db_get xserver-xorg/autodetect_monitor"
  db_go
  db_get xserver-xorg/autodetect_monitor || debug_echo "db_get xserver-xorg/autodetect_monitor"
  # well, you'd better like the values you get, eh?
  if [ "$RET" = "true" ]; then
    AUTODETECT_VIDEO="yes"
  fi
  if [ -n "$AUTODETECT_VIDEO" ] && [ -z "$UPGRADE" ]; then
    # clean vars
    MONITOR_IDENTIFIER=
    RESOLUTIONS=
    HORIZ_SYNC=
    VERT_REFRESH=

    # clear out all values
    for i in identifier horiz-sync vert-refresh use_sync_ranges \
             selection-method screen-size; do
      db_reset xserver-xorg/config/monitor/$i
    done

    for i in modes; do
      db_reset xserver-xorg/config/display/$i
    done
    # Support preseeding of this one even when autodetecting; will mean
    # people get the wrong default presented on second and subsequent
    # low-priority reconfigures, though. Too bad.
    for i in default_depth; do
      db_fget xserver-xorg/config/display/$i seen
      if [ "$RET" = false ]; then
        db_reset xserver-xorg/config/display/$i
      fi
    done
    
    db_get xserver-xorg/config/device/driver || debug_echo "db_get xserver-xorg/config/device/driver"
    DEVICE_DRIVER="$RET"
    db_get xserver-xorg/config/device/identifier || debug_echo "db_get xserver-xorg/config/device/driver"
    DEVICE_IDENTIFIER="$RET"

    # first install, we attempt a probe
    if which xresprobe >/dev/null 2>&1; then
      set +e
      PROBE_DUMP="$(xresprobe "$DEVICE_DRIVER")"
      set -e
    fi

    # Set proper vars.
    MONITOR_IDENTIFIER="$(echo "$PROBE_DUMP" | grep "^id:" | sed -e 's/^id: //g' -e 's/"//g')"
    RESOLUTIONS="$(echo "$PROBE_DUMP" | grep "^res:" | sed -e 's/^res: //g')"
    HORIZ_SYNC="$(echo "$PROBE_DUMP" | grep "^freq:" | sed -e 's/^freq: //g' | cut -d " " -f 1)"
    VERT_REFRESH="$(echo "$PROBE_DUMP" | grep "^freq:" | sed -e 's/^freq: //g' | cut -d " " -f 2)"
    DISPLAY_TYPE="$(echo "$PROBE_DUMP" | grep "^disptype:" | sed -e 's/^disptype: //g')"
    DISPLAY_DEPTH="$(echo "$PROBE_DUMP" | grep "^depth:" | sed -e 's/^depth: //g')"

    if [ -n "$XORG_SYNC_RANGES" ]; then
      debug_echo "writing sync ranges due to XORG_SYNC_RANGES"
      MONITOR_SYNC_RANGES="yes"
    fi
  
    # nv, savage, trident and via will take the panel resolution from a BIOS table,
    # but  then fail to infer sane sync ranges from these, so mode validation will
    # fail when it uses the standard VGA sync ranges.  hack around this by producing
    # a sane sync range for the resolution in the config file when they're almost
    # certain to be using LVDS.
    if [ "$DEVICE_DRIVER" = "nv" ] || [ "$DEVICE_DRIVER" = "savage" ] || \
       [ "$DEVICE_DRIVER" = "trident" ] || [ "$DEVICE_DRIVER" = "via" ] || \
       [ "$DEVICE_DRIVER" = "siliconmotion" ] || \
       [ "$DEVICE_DRIVER" = "chips" ] || [ "$DEVICE_DRIVER" = "tdfx" ] || \
       [ "$DEVICE_DRIVER" = "neomagic" ]; then
      if [ "$DISPLAY_TYPE" = "lcd/lvds" ]; then
        debug_echo "known-bad laptop chipset detected; writing sync ranges"
        MONITOR_SYNC_RANGES="yes"
      fi
    fi

    if [ "$DEVICE_DRIVER" = "s3" ]; then
      debug_echo "known-bad chipset detected; writing sync ranges"
      MONITOR_SYNC_RANGES="yes"
    fi

    if [ "$DEVICE_DRIVER" = "ati" ]; then
      # r128 is in the same 'special' list, AFAICT.
      if [ "$DISPLAY_TYPE" = "lcd/lvds" ]; then
        if [ "$DEVICE_IDENTIFIER" = "ATI Technologies Inc Rage Mobility M3 (AGP)" ] || \
           [ "$DEVICE_IDENTIFIER" = "ATI Technologies Inc Rage Mobility M4 (AGP)" ] || \
           echo "$DEVICE_IDENTIFIER" | grep -q "Rage 128"; then
          MONITOR_SYNC_RANGES="yes"
          debug_echo "r128 laptop chipset detected; writing sync ranges"
        fi
      else
        # ddc via i2c on ati/powerpc seems to be too flaky to be relied upon
        if [ "$ARCHITECTURE" = "powerpc" ]; then
          MONITOR_SYNC_RANGES="yes"
          debug_echo "ati chipset on powerpc detected; writing sync ranges"
        fi
      fi
    fi

    if [ "$DEVICE_DRIVER" = "i810" ]; then
      # and i810, but *not* i830
      if [ "$DISPLAY_TYPE" = "lcd/lvds" ]; then
        if [ "$DEVICE_IDENTIFIER" = "Intel Corporation 82810 CGC [Chipset Graphics Controller]" ] || \
           [ "$DEVICE_IDENTIFIER" = "Intel Corporation 82810 DC-100 CGC [Chipset Graphics Controller]" ] || \
           [ "$DEVICE_IDENTIFIER" = "Intel Corporation 82810E DC-133 CGC [Chipset Graphics Controller]" ] || \
           [ "$DEVICE_IDENTIFIER" = "Intel Corporation 82815 CGC [Chipset Graphics Controller]" ]; then
          MONITOR_SYNC_RANGES="yes"
          debug_echo "i810 laptop chipset detected; writing sync ranges"
        fi
      fi
    fi
  else
    # reconfiguring. debconf should have sane defaults
    db_get xserver-xorg/config/monitor/identifier || debug_echo "db_get xserver-xorg/config/monitor/identifier"
    MONITOR_IDENTIFIER="$RET"
    db_get xserver-xorg/config/display/modes || debug_echo "db_get xserver-xorg/config/display/modes"
    RESOLUTIONS=$(echo "$RET" | sed -e 's/,//g')
    db_get xserver-xorg/config/monitor/horiz-sync || debug_echo "db_get xserver-xorg/config/monitor/horiz-sync"
    HORIZ_SYNC="$RET"
    db_get xserver-xorg/config/monitor/vert-refresh || debug_echo "db_get xserver-xorg/config/monitor/vert-refresh"
    VERT_REFRESH="$RET"
    db_get xserver-xorg/config/monitor/use_sync_ranges || debug_echo "db_get xserver-xorg/config/monitor/use_sync_ranges"
    if [ "$RET" = "true" ]; then
      MONITOR_SYNC_RANGES="yes"
      debug_echo "preserving sync ranges from debconf"
    fi
  fi

  # Set a sane monitor id default if probe fails
  if [ -z "$MONITOR_IDENTIFIER" ]; then
    # fall back to some language-specific generic text
    db_metaget xserver-xorg/config/monitor/default-identifier Description
    MONITOR_IDENTIFIER=$RET
  fi
  db_set xserver-xorg/config/monitor/identifier "$MONITOR_IDENTIFIER"
  MAY_BE_NULL="" validate_string_db_input low xserver-xorg/config/monitor/identifier || true


  # Resolution hell:
  # we need to know if we probed resolutions, if so add them to debconf template
  # as choices, so that we don't lose them across updates or reconfiguration.
  PRIORITY="high"
  if [ -n "$AUTODETECT_VIDEO" ]; then
    NRES=0
    for i in $RESOLUTIONS; do
      NRES="$(expr $NRES + 1)"
    done

    if [ "$NRES" -gt "0" ]; then
      # got RESOLUTIONS. Lower question priority
      PRIORITY=medium
      DCRESOLUTIONS="$(for i in $DCRESOLUTIONS $RESOLUTIONS; do echo $i; done | sort -t x -k1,1nr -k2,2nr -u)"
      DCRESOLUTIONS="$(echo $DCRESOLUTIONS | sed -e 's/ /, /g')"
    fi

    # if we're not running an internal panel and we don't have a list of sync
    # ranges, X isn't going to be able to figure it out; give it a hand
    if [ -z "$UPGRADE" ]; then
      if ! [ "$DISPLAY_TYPE" = "lcd/lvds" ]; then
        if [ -z "$HORIZ_SYNC" ] || [ -z "$VERT_REFRESH" ]; then
          # the actual default sync ranges are calculated further down
          MONITOR_SYNC_RANGES="yes"
          debug_echo "no sync ranges available from DDC; writing own ranges"
        fi
      fi
    fi
  fi

  if [ -n "$UPGRADE" ]; then
    # drop priority on upgrades
    PRIORITY="medium"
  fi

  db_metaget xserver-xorg/config/display/modes choices
  DEFRESOLUTIONS="$(echo @DEFAULT_DCRESOLUTIONS@ | sed -e 's/, / /g')"
  if [ -n "$RET" ]; then
    DCRESOLUTIONS="$RET"
    DCRESOLUTIONS="$(echo $DCRESOLUTIONS | sed -e 's/, / /g')"
  else
    DCRESOLUTIONS=$DEFRESOLUTIONS
  fi
  if [ -n "$RESOLUTIONS" ]; then
    DCRESOLUTIONS="$(for i in $DCRESOLUTIONS $DEFRESOLUTIONS $RESOLUTIONS; do echo $i; done | sort -t x -k1,1nr -k2,2nr -u)"
  fi
  # set the old choice + the probed ones (if any).
  DCRESOLUTIONS="$(echo $DCRESOLUTIONS | sed -e 's/ /, /g')"
  db_subst xserver-xorg/config/display/modes choices "$DCRESOLUTIONS"
  if [ -n "$RESOLUTIONS" ]; then
    RESOLUTIONS="$(echo $RESOLUTIONS | sed -e 's/ /, /g')"
    db_set xserver-xorg/config/display/modes "$RESOLUTIONS"
  fi
  db_input $PRIORITY xserver-xorg/config/display/modes || debug_echo "db_input $PRIORITY xserver-xorg/config/display/modes"
  db_go

  db_subst xserver-xorg/config/monitor/selection-method choices "Simple, Medium, Advanced"
  db_subst xserver-xorg/config/monitor/selection-method default "Medium"

  if [ -n "$AUTODETECT_VIDEO" ]; then
    if [ -n "$HORIZ_SYNC" ] && [ -n "$VERT_REFRESH" ]; then
      # monitor frequencies detected, we set them as defaults and we switch to Advanced mode.
      # there is no need to get crazy feeding "Medium"
      db_set xserver-xorg/config/monitor/horiz-sync "$HORIZ_SYNC"
      db_set xserver-xorg/config/monitor/vert-refresh "$VERT_REFRESH"
      db_set xserver-xorg/config/monitor/selection-method "Advanced"
    else
      # if we are here we did not detect the frequencies, but we have the resolution.
      # get the highest resolution.
      db_get xserver-xorg/config/display/modes || debug_echo "db_get xserver-xorg/config/display/modes"
      if [ -n "$RET" ]; then
        # Only do this if the user selects at least one mode to write to the 
        # conf file. If not, then the section won't be written by dexconf
        # and the server will pick the highest mode it can figure out
        MAXRES="$(echo $RET | sed -e 's/,//g')"
        MAXRES="$(for i in $MAXRES; do echo $i; done | sort -t x -k1,1nr -k2,2nr -u | head -n 1)"
        # set a sane default for mode-list
        MAXRES="$MAXRES @ 60Hz"
        db_set xserver-xorg/config/monitor/mode-list "$MAXRES"
        # apparently all the known resolution/horiz-sync combinantion have a ratio that
        # can go from 19 to 21. Only one exception was 18. We can safely assume a ratio of 20
        # for default setup. DDC should do the rest.
        HMAX=$(echo "$MAXRES" | cut -d "x" -f 1)
        HMAX=$(expr "$HMAX" / 20)
        # set sane defaults as fallback, in case there is no mode-list match otherwise we
        # prefer a well known match.
        HORIZ_SYNC="28-$HMAX"
        VERT_REFRESH="43-60"
        db_set xserver-xorg/config/monitor/horiz-sync "$HORIZ_SYNC"
        db_set xserver-xorg/config/monitor/vert-refresh "$VERT_REFRESH"
        db_set xserver-xorg/config/monitor/selection-method "Advanced"
      fi
    fi
  fi

  db_input low xserver-xorg/config/monitor/selection-method || debug_echo "db_input low xserver-xorg/config/monitor/selection-method"
  db_go

  db_get xserver-xorg/config/monitor/selection-method
  case "$RET" in
    Simple)
      db_input low xserver-xorg/config/monitor/screen-size || debug_echo "db_input low xserver-xorg/config/monitor/screen-size"
      db_go
      db_get xserver-xorg/config/monitor/screen-size
      case "$RET" in
        'Up to 14 inches (355 mm)')
          db_set xserver-xorg/config/monitor/horiz-sync "28-33"
          db_set xserver-xorg/config/monitor/vert-refresh "43-72"
          ;;
        '15 inches (380 mm)')
          db_set xserver-xorg/config/monitor/horiz-sync "28-50"
          db_set xserver-xorg/config/monitor/vert-refresh "43-75"
          ;;
        '17 inches (430 mm)')
          db_set xserver-xorg/config/monitor/horiz-sync "30-70"
          db_set xserver-xorg/config/monitor/vert-refresh "50-160"
          ;;
        '19-20 inches (480-510 mm)')
          db_set xserver-xorg/config/monitor/horiz-sync "30-100"
          db_set xserver-xorg/config/monitor/vert-refresh "50-160"
          ;;
        '21 inches (530 mm) or more')
          db_set xserver-xorg/config/monitor/horiz-sync "30-130"
          db_set xserver-xorg/config/monitor/vert-refresh "50-160"
          ;;
      esac
      ;;
    Medium)
      db_input low xserver-xorg/config/monitor/mode-list || true
      db_go
      if [ -n "$MAXRES" ]; then
        RET="$MAXRES"
      else
        db_get xserver-xorg/config/monitor/mode-list
      fi
      case "$RET" in
        "640x480 @ 60Hz")
          db_set xserver-xorg/config/monitor/horiz-sync "28-33"
          db_set xserver-xorg/config/monitor/vert-refresh "43-72"
          ;;
        "640x480 @ 72Hz")
          db_set xserver-xorg/config/monitor/horiz-sync "28-38"
          db_set xserver-xorg/config/monitor/vert-refresh "43-72"
          ;;
        "800x600 @ 60Hz")
          db_set xserver-xorg/config/monitor/horiz-sync "28-38"
          db_set xserver-xorg/config/monitor/vert-refresh "43-72"
          ;;
        "800x600 @ 72Hz")
          db_set xserver-xorg/config/monitor/horiz-sync "28-48"
          db_set xserver-xorg/config/monitor/vert-refresh "43-72"
          ;;
        "800x600 @ 85Hz")
          db_set xserver-xorg/config/monitor/horiz-sync "30-54"
          db_set xserver-xorg/config/monitor/vert-refresh "50-85"
          ;;
        "832x624 @ 75Hz")
          db_set xserver-xorg/config/monitor/horiz-sync "30-50"
          db_set xserver-xorg/config/monitor/vert-refresh "50-75"
          ;;
        "1024x768 @ 60Hz")
          db_set xserver-xorg/config/monitor/horiz-sync "28-49"
          db_set xserver-xorg/config/monitor/vert-refresh "43-72"
          ;;
        "1024x768 @ 70Hz")
          db_set xserver-xorg/config/monitor/horiz-sync "30-57"
          db_set xserver-xorg/config/monitor/vert-refresh "43-72"
          ;;
        "1024x768 @ 75Hz")
          db_set xserver-xorg/config/monitor/horiz-sync "30-60"
          db_set xserver-xorg/config/monitor/vert-refresh "50-75"
          ;;
        "1152x768 @ 54.8Hz")
          # This is a 15" PowerBook G4 mode; its video hardware (LCD) was also
          # capable of 896x600 and 720x480 pixels at a 3:2 aspect ratio and
          # 1024x768, 800x600, and 640x480 pixels at a 4:3 aspect ratio, so give
          # its horizontal and vertical ranges a little more "headroom" than
          # that required by this specific mode to accomodate the others.
          db_set xserver-xorg/config/monitor/horiz-sync "30-50"
          db_set xserver-xorg/config/monitor/vert-refresh "50-72"
          ;;
        "1152x864 @ 60Hz")
          db_set xserver-xorg/config/monitor/horiz-sync "30-68"
          db_set xserver-xorg/config/monitor/vert-refresh "50-70"
          ;;
        "1152x864 @ 75Hz")
          db_set xserver-xorg/config/monitor/horiz-sync "30-68"
          db_set xserver-xorg/config/monitor/vert-refresh "50-85"
          ;;
        "1280x768 @ 60Hz")
          db_set xserver-xorg/config/monitor/horiz-sync "30-65"
          db_set xserver-xorg/config/monitor/vert-refresh "30-60"
          ;;
        "1280x800 @ 60Hz")
          db_set xserver-xorg/config/monitor/horiz-sync "30-67"
          db_set xserver-xorg/config/monitor/vert-refresh "30-60"
          ;;
        "1280x960 @ 60Hz")
          db_set xserver-xorg/config/monitor/horiz-sync "30-60"
          db_set xserver-xorg/config/monitor/vert-refresh "50-75"
          ;;
        "1280x960 @ 85Hz")
          db_set xserver-xorg/config/monitor/horiz-sync "30-92"
          db_set xserver-xorg/config/monitor/vert-refresh "50-85"
          ;;
        "1280x1024 @ 60Hz")
          db_set xserver-xorg/config/monitor/horiz-sync "30-65"
          db_set xserver-xorg/config/monitor/vert-refresh "50-75"
          ;;
        "1400x1050 @ 60Hz")
          db_set xserver-xorg/config/monitor/horiz-sync "30-67"
          db_set xserver-xorg/config/monitor/vert-refresh "50-75"
          ;;
        "1400x1050 @ 75Hz")
          db_set xserver-xorg/config/monitor/horiz-sync "30-85"
          db_set xserver-xorg/config/monitor/vert-refresh "50-80"
          ;;
        "1600x1024 @ 85Hz")
          db_set xserver-xorg/config/monitor/horiz-sync "30-70"
          db_set xserver-xorg/config/monitor/vert-refresh "50-90"
          ;;
        "1600x1200 @ 60Hz")
          db_set xserver-xorg/config/monitor/horiz-sync "30-75"
          db_set xserver-xorg/config/monitor/vert-refresh "50-85"
          ;;
        "1600x1200 @ 75Hz")
          db_set xserver-xorg/config/monitor/horiz-sync "30-94"
          db_set xserver-xorg/config/monitor/vert-refresh "50-75"
          ;;
        "1600x1200 @ 85Hz")
          db_set xserver-xorg/config/monitor/horiz-sync "30-107"
          db_set xserver-xorg/config/monitor/vert-refresh "50-85"
          ;;
        "1680x1050 @ 60Hz")
          db_set xserver-xorg/config/monitor/horiz-sync "30-90"
          db_set xserver-xorg/config/monitor/vert-refresh "50-60"
          ;;
        "1792x1344 @ 75Hz")
          db_set xserver-xorg/config/monitor/horiz-sync "30-107"
          db_set xserver-xorg/config/monitor/vert-refresh "50-85"
          ;;
        "1792x1344 @ 60Hz")
          db_set xserver-xorg/config/monitor/horiz-sync "30-84"
          db_set xserver-xorg/config/monitor/vert-refresh "50-75"
          ;;
        "1856x1392 @ 60Hz")
          db_set xserver-xorg/config/monitor/horiz-sync "30-87"
          db_set xserver-xorg/config/monitor/vert-refresh "50-75"
          ;;
        "1856x1392 @ 75Hz")
          db_set xserver-xorg/config/monitor/horiz-sync "30-113"
          db_set xserver-xorg/config/monitor/vert-refresh "50-75"
          ;;
        "1920x1200 @ 60Hz")
          db_set xserver-xorg/config/monitor/horiz-sync "30-75"
          db_set xserver-xorg/config/monitor/vert-refresh "30-60"
          ;;
        "1920x1440 @ 60Hz")
          db_set xserver-xorg/config/monitor/horiz-sync "30-90"
          db_set xserver-xorg/config/monitor/vert-refresh "50-75"
          ;;
        "1920x1440 @ 75Hz")
          db_set xserver-xorg/config/monitor/horiz-sync "30-130"
          db_set xserver-xorg/config/monitor/vert-refresh "60-160"
          ;;
        "1920x1440 @ 85Hz")
          db_set xserver-xorg/config/monitor/horiz-sync "30-130"
          db_set xserver-xorg/config/monitor/vert-refresh "60-160"
          ;;
        "2048x1536 @ 60Hz")
          db_set xserver-xorg/config/monitor/horiz-sync "30-100"
          db_set xserver-xorg/config/monitor/vert-refresh "60-85"
          ;;
        "2048x1536 @ 75Hz")
          db_set xserver-xorg/config/monitor/horiz-sync "30-125"
          db_set xserver-xorg/config/monitor/vert-refresh "60-100"
          ;;
        "2048x1536 @ 85Hz")
          db_set xserver-xorg/config/monitor/horiz-sync "30-140"
          db_set xserver-xorg/config/monitor/vert-refresh "60-160"
          ;;
      esac
      ;;
    Advanced)
      validate_monitor_frequency_db_input low xserver-xorg/config/monitor/horiz-sync || true
      validate_monitor_frequency_db_input low xserver-xorg/config/monitor/vert-refresh || true
      db_go
      ;;
  esac

  # don't write sync ranges if it's exactly what we picked up from DDC
  db_get xserver-xorg/config/monitor/horiz-sync
  USER_HSYNC="$RET"
  db_get xserver-xorg/config/monitor/vert-refresh
  USER_VREFRESH="$RET"
  if [ -z "$UPGRADE" ]; then
    if [ -n "$AUTODETECT_VIDEO" ]; then
       if ! [ "$USER_HSYNC" = "$HORIZ_SYNC" ] || \
          ! [ "$USER_VREFRESH" = "$VERT_REFRESH" ]; then
        MONITOR_SYNC_RANGES="yes"
        debug_echo "writing out user-customised sync ranges"
       fi
    else
      # always write them out if we refused probing for some reason
      MONITOR_SYNC_RANGES="yes"
      debug_echo "not probing; writing out sync ranges"
    fi
    # we don't do anything here because we're just upgrading; leave it alone.
  fi

  if [ -n "$MONITOR_SYNC_RANGES" ]; then
    db_set xserver-xorg/config/monitor/use_sync_ranges true
  fi
  db_input low xserver-xorg/config/monitor/use_sync_ranges || debug_echo "db_input low xserver-xorg/config/monitor/use_sync_ranges"

  case "$DEVICE_DRIVER" in
    newport)
      DEFAULT_DEPTH=8
      ;;
    vga)
      DEFAULT_DEPTH=4
      ;;
    # Voodoo3's can't do 1024x768x24 and still cope with DRI; this is a common
    # setup, apparently, so default to 16bpp.
    tdfx)
      DEFAULT_DEPTH=16
      ;;
    # nVidia laptop chipsets should use 16bpp per default, or face horrific
    # colour banding issues, per Olivier Grawert and Trent Lloyd.
    nv)
      if [ -n "$LAPTOP" ]; then
        DEFAULT_DEPTH=16
      else
        DEFAULT_DEPTH=24
      fi
      ;;
    # apparently this driver needs some hot hot depth action too.
    savage)
      DEFAULT_DEPTH=16
      ;;
    suncg6)
      DEFAULT_DEPTH=8
      ;;
    *)
      DEFAULT_DEPTH=24
      ;;
  esac

  if [ -n "$DISPLAY_DEPTH" ]; then
    DEFAULT_DEPTH="$DISPLAY_DEPTH"
  fi

  db_fget xserver-xorg/config/display/default_depth seen
  if [ "$RET" = "false" ]; then
    db_set xserver-xorg/config/display/default_depth $DEFAULT_DEPTH
  fi

  db_input low xserver-xorg/config/display/default_depth || true
  db_go
}

# register this package as a (potential) handler of the X server symlink and
# X.Org X server configuration file
for ROSTER in "$SERVER_SYMLINK_ROSTER" "$XORGCONFIG_ROSTER"; do
  if ! fgrep -qsx "$THIS_PACKAGE" "$ROSTER"; then
    echo "$THIS_PACKAGE" >> "$ROSTER"
  fi
done

# only mess with the server symlink file if it is a symbolic link or does
# not exist.  otherwise, assume that's the way the user wants it.
if [ -L "$SERVER_SYMLINK" ] || ! [ -e "$SERVER_SYMLINK" ]; then
  # migrate from old symlinks.
  if [ "$(readlink /etc/X11/X)" = "/usr/X11R6/bin/Xorg" ] || \
     [ "$(readlink /etc/X11/X)" = "/usr/bin/X11/Xorg" ] || \
     [ "$(readlink /etc/X11/X)" = "/bin/true" ]; then
    rm /etc/X11/X
    ln -s $THIS_SERVER /etc/X11/X
  fi

  # apparently on some broken upgrades the SERVER_SYMLINK_CHECKSUM has been 
  # lost. If it does not exists, make sure to recreate it.

  if [ ! -e "$SERVER_SYMLINK_CHECKSUM" ] && [ -L "$SERVER_SYMLINK" ]; then
    readlink "$SERVER_SYMLINK" | md5sum > "$SERVER_SYMLINK_CHECKSUM"
  fi

  # compare the current and stored checksums; if they do not match, assume
  # that's the way the user wants it.
  # why, why, why, why, why, why, why are we md5suming this? -daniels
  if [ "$(readlink "$SERVER_SYMLINK" | md5sum)" = \
       "$(cat "$SERVER_SYMLINK_CHECKSUM")" ] || \
     [ "$(echo "/usr/X11R6/bin/Xorg" | md5sum)" = \
       "$(cat "$SERVER_SYMLINK_CHECKSUM")" ] || \
     [ "$(echo "/usr/bin/X11/Xorg" | md5sum)" = \
       "$(cat "$SERVER_SYMLINK_CHECKSUM")" ] || \
     [ "$(echo "/usr/bin/X11/XFree86" | md5sum)" = \
       "$(cat "$SERVER_SYMLINK_CHECKSUM")" ] || \
     [ "$(echo "/bin/true" | md5sum)" = \
       "$(cat "$SERVER_SYMLINK_CHECKSUM")" ] || \
     ! [ -e "$SERVER_SYMLINK" ]; then
    # finally, only update the symlink if this package contains the
    # selected default X server.
    db_get shared/default-x-server
    if [ -n "$RET" ]; then
      SELECTED_PACKAGE="$RET"
      if [ "$SELECTED_PACKAGE" = "$THIS_PACKAGE" ]; then
        # prepare a new version of the config file; this is a symlink so we
        # can't use the tempfile command for it (we'd have to subsequently
        # use ln -sf, which is subject to race condition attacks)
        NEW_SERVER_SYMLINK="$SERVER_SYMLINK.dpkg-new"
        ln -sf "$THIS_SERVER" "$NEW_SERVER_SYMLINK"
        if ! cmp -s "$SERVER_SYMLINK" "$NEW_SERVER_SYMLINK"; then
          if [ "$(readlink "$SERVER_SYMLINK")" \
               != "$(readlink "$NEW_SERVER_SYMLINK")" ]; then
            mv "$NEW_SERVER_SYMLINK" "$SERVER_SYMLINK"
            readlink "$SERVER_SYMLINK" | md5sum > \
                     "$SERVER_SYMLINK_CHECKSUM"
          fi
        fi
        rm -f "$NEW_SERVER_SYMLINK"
      fi
    else
      warn "not updating $SERVER_SYMLINK; no default X server" \
           "configured; run \"dpkg-reconfigure $THIS_PACKAGE\" to" \
           "correct this"
    fi
  else
    warn "not updating $SERVER_SYMLINK; file has been customized"
  fi
else
  warn "not updating $SERVER_SYMLINK; file exists but is not a symlink"
fi

# Don't touch the config on upgrades except to deal with known issues with old
# configs.
if [ -z "$UPGRADE" ] || dpkg --compare-versions "$2" le "1:7.0.14"; then
  # compare the current and stored checksums; if they do not match, assume
  # that's the way the user wants it.  if we're reconfiguring, overwrite
  # it regardless and back it up.
  if [ "$(md5sum "$XORGCONFIG")" = "$(cat "$XORGCONFIG_CHECKSUM")" ] || \
     ! [ -e "$XORGCONFIG" ] || [ -n "$RECONFIGURE" ]; then
    # they match or user deleted the file or they're running dpkg-reconfigure; 
    # prepare a new version
    NEW_XORGCONFIG="$XORGCONFIG.dpkg-new"
    if [ -n "$XRESPROBE_DEBUG" ]; then
      set -x
    fi
    xresprobeint
    if [ -n "$XRESPROBE_DEBUG" ]; then
      set +x
    fi
    if [ -n "$RECONFIGURE" ] && [ -e "$XORGCONFIG" ]; then
      BACKUP_XORGCONFIG="$XORGCONFIG.$(date '+%Y%m%d%H%M%S')"
      if [ -e "$BACKUP_XORGCONFIG" ]; then
        bomb "backup xorg.conf file $BACKUP_XORGCONFIG already" \
             "exists; please remove it and try again"
      fi
      cp "$XORGCONFIG" "$BACKUP_XORGCONFIG"
      warn "overwriting possibly-customised configuration file; backup" \
           "in $BACKUP_XORGCONFIG"
    fi
    if dexconf -o "$NEW_XORGCONFIG"; then
      if ! cmp -s "$XORGCONFIG" "$NEW_XORGCONFIG"; then
        mv "$NEW_XORGCONFIG" "$XORGCONFIG"
        md5sum "$XORGCONFIG" > "$XORGCONFIG_CHECKSUM"
      fi
    else
      warn "error while preparing new Xorg X server configuration" \
           "file in $NEW_XORGCONFIG; not attempting to update existing" \
           "configuration"
    fi
    rm -f "$NEW_XORGCONFIG"
  else
    # I'm going to get in so much shit for this...
    BACKUP_XORGCONFIG="$XORGCONFIG.$(date '+%Y%m%d%H%M%S')"
    warn "$XORGCONFIG has been customized, but we need to make updates. Backing up your config to $BACKUP_XORGCONFIG. If we screw something up, restore using this file."
      cp "$XORGCONFIG" "$BACKUP_XORGCONFIG"
    sed -e'
	# Dump obsolete modules
	/^[[:space:]]*Section[[:space:]]\+"Module"[[:space:]]*$/,/^[[:space:]]*EndSection[[:space:]]*$/ {
		/^[[:space:]]*Load[[:space:]]\+"GLcore"[[:space:]]*$/d
		/^[[:space:]]*Load[[:space:]]\+"speedo"[[:space:]]*$/d
		/^[[:space:]]*Load[[:space:]]\+"type1"[[:space:]]*$/d
	}
	/^[[:space:]]*Section[[:space:]]\+"Files"[[:space:]]*$/,/*[[:space:]]*EndSection[[:space:]]*$/ {
		# Delete the module path
		/^[[:space:]]*ModulePath[[:space:]]\+/d
		# Delete the rgb path
		/^[[:space:]]*RgbPath[[:space:]]\+/d
		# Change font paths for the fonts xorg-x11 used to ship
		#/^[[:space:]]*FontPath[[:space:]]\+"\/usr\/share\/fonts\/X11\/misc"[[:space:]]*$/d
		#/^[[:space:]]*FontPath[[:space:]]\+"\/usr\/share\/fonts\/X11\/cyrillic"[[:space:]]*$/d
		#/^[[:space:]]*FontPath[[:space:]]\+"\/usr\/share\/fonts\/X11\/100dpi"[[:space:]]*$/d
		#/^[[:space:]]*FontPath[[:space:]]\+"\/usr\/share\/fonts\/X11\/75dpi"[[:space:]]*$/d
		#/^[[:space:]]*FontPath[[:space:]]\+"\/usr\/share\/fonts\/X11\/Type1"[[:space:]]*$/d
		#/^[[:space:]]*FontPath[[:space:]]\+"\/usr\/share\/fonts\/X11\/CID"[[:space:]]*$/d
		/^[[:space:]]*FontPath[[:space:]]\+"\/usr\/share\/fonts\/X11\/Speedo"[[:space:]]*$/d
		/^[[:space:]]*FontPath[[:space:]]\+"\/usr\/lib\/X11\/fonts\/misc"[[:space:]]*$/i\
	FontPath	"/usr/share/fonts/X11/misc"
		/^[[:space:]]*FontPath[[:space:]]\+"\/usr\/lib\/X11\/fonts\/cyrillic"[[:space:]]*$/i\
	FontPath	"/usr/share/fonts/X11/cyrillic"
		/^[[:space:]]*FontPath[[:space:]]\+"\/usr\/lib\/X11\/fonts\/100dpi"[[:space:]]*$/i\
	FontPath	"/usr/share/fonts/X11/100dpi"
		/^[[:space:]]*FontPath[[:space:]]\+"\/usr\/lib\/X11\/fonts\/75dpi"[[:space:]]*$/i\
	FontPath	"/usr/share/fonts/X11/75dpi"
		/^[[:space:]]*FontPath[[:space:]]\+"\/usr\/lib\/X11\/fonts\/Type1"[[:space:]]*$/i\
	FontPath	"/usr/share/fonts/X11/Type1"
		/^[[:space:]]*FontPath[[:space:]]\+"\/usr\/lib\/X11\/fonts\/CID"[[:space:]]*$/d
	}
	' $XORGCONFIG > ${XORGCONFIG}.madwizard-new
	chown --reference=$XORGCONFIG ${XORGCONFIG}.madwizard-new
	chmod --reference=$XORGCONFIG ${XORGCONFIG}.madwizard-new
	mv ${XORGCONFIG}.madwizard-new $XORGCONFIG
  fi
else
  debug_echo "not updating $XORGCONFIG; we're upgrading"
fi

exit 0

# vim:set ai et sts=2 sw=2 tw=0:
